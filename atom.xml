<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leo&#39;s Blog</title>
  
  <subtitle>Don&#39;t Worry, Be happy</subtitle>
  <link href="https://tauleos.github.io/atom.xml" rel="self"/>
  
  <link href="https://tauleos.github.io/"/>
  <updated>2024-11-07T08:17:00.699Z</updated>
  <id>https://tauleos.github.io/</id>
  
  <author>
    <name>Tauleos</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Chrome插件进阶</title>
    <link href="https://tauleos.github.io/dcc6a7fe224e.html"/>
    <id>https://tauleos.github.io/dcc6a7fe224e.html</id>
    <published>2024-11-07T07:34:38.000Z</published>
    <updated>2024-11-07T08:17:00.699Z</updated>
    
    <content type="html"><![CDATA[<p>上文我们了解了如何实现一个基础版的插件开发。当然，在现代开发模式下，我们肯定不能接受如此简陋的开发模式，那么我们如何进行下一步的优化呢，现在我们继续就如何使用组件库和热更新融合方面进行探索</p><span id="more"></span><h1 id="一、优化"><a href="#一、优化" class="headerlink" title="一、优化"></a>一、优化</h1><p>如今前端工具百花齐放。我们放着更好的工具不用岂不是浪费。能不能把我们的前端工具集成到chrome插件开发过程中，来实现更快捷的开发体验和更合适的ui展示呢？那我们就试着把vite+vue接入进来吧。</p><h2 id="目录调整"><a href="#目录调整" class="headerlink" title="目录调整"></a>目录调整</h2><ol><li>首先我们先快速生成vite与vue，TS的项目，</li><li>同时调整目录结构，将我们需要的content、popup等功能分开在不同的结构中。</li><li>安装组件库、pinia等工具；安装chrome-types 来对我们的api进行提示</li></ol><p>目录结构如下所示<br><img src="/images/extension/101730966937_.pic.jpg" alt="image.png"></p><h2 id="vite配置"><a href="#vite配置" class="headerlink" title="vite配置"></a>vite配置</h2><ol><li>通过<code>rollup-plugin-copy</code> 将静态资源（<code>manifest.json</code>、图标）等文件复制到打包后的目录中</li><li>通过设置vite的<code>build</code>选项,将<code>content</code>、<code>popup</code>等设置为打包的入口，并输出到manifest设置的目录中。<br>vite配置如下所示：<br><img src="/images/extension/111730966938_.pic.jpg" alt="image.png"></li></ol><p>打包之后，我们把打包后的文件夹扔到浏览器中，就可以达到我们上述第二步的目标。</p><blockquote><p>但是，如何能进一步方便我们的开发过程呢？在我们日常开发过程中的热加载可不可以也用上呢?</p></blockquote><h2 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h2><p>我们知道。webpack或者vite的dev环境下，工具为我们自动集成了HMR功能，可以使我们改动的代码自动更新到页面上。但是chrome插件与普通的浏览器页面不太一样。插件更新的话是需要在管理界面手动刷新插件，同时需要重新打开popup，整个插件的代码才会更新。所以有没有办法可以在插件内监听文件夹的变化呢？</p><h3 id="1、Chrome-runtime-getPackageDirectoryEntry"><a href="#1、Chrome-runtime-getPackageDirectoryEntry" class="headerlink" title="1、Chrome.runtime.getPackageDirectoryEntry"></a>1、Chrome.runtime.getPackageDirectoryEntry</h3><p>根据官方文档介绍。<code>getPackageDirectoryEntry</code> 可以获取文件夹内容并监听其变化。可是在V3版本中被限制了，只能在<code>popup</code>页面中使用，如果<code>popup</code>没有被点击弹出来的话，无法做到其他模块的热更新的。</p><h3 id="2、live-server-vite-watch-轮询"><a href="#2、live-server-vite-watch-轮询" class="headerlink" title="2、live-server + vite watch + 轮询"></a>2、live-server + vite watch + 轮询</h3><ol><li>通过<code>vite --watch build</code> 来自动编译我们的改动到dist文件。</li><li>通过 <code>live-server</code> 在本地启动一个静态资源服务器，保证所有的dist文件都可以热更新。</li><li>在 <code>background</code> 脚本中对所有的静态资源进行轮询，保存上一次的内容与这一次进行对比，发现内容有变化的话调用api进行更新<br>描述代码如下所示：</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fileList = [</span><br><span class="line">      <span class="string">&#x27;http://127.0.0.1:5501/dist/manifest.json&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;http://127.0.0.1:5501/dist/popup/popup.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;http://127.0.0.1:5501/dist/background/service-worker.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;http://127.0.0.1:5501/dist/content/content.js&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;http://127.0.0.1:5501/dist/contentPage/contentPage.js&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">fileObj</span>:  = &#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reload 重新加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reload</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">currentWindow</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">tabs: chrome.tabs.Tab[]</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (tabs[<span class="number">0</span>]) &#123;</span><br><span class="line">            chrome.<span class="property">tabs</span>.<span class="title function_">reload</span>(tabs[<span class="number">0</span>].<span class="property">id</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          chrome.<span class="property">runtime</span>.<span class="title function_">reload</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历监听的文件，通过请求获取文件内容，判断是否需要刷新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">checkReloadPage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      fileList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">fetch</span>(item).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> res.<span class="title function_">text</span>())</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">files</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (fileObj[item] &amp;&amp; fileObj[item] !== files) &#123;</span><br><span class="line">            <span class="title function_">reload</span>()</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fileObj[item] = files</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">checkReloadPage</span>()</span><br><span class="line"> &#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="3、websocket"><a href="#3、websocket" class="headerlink" title="3、websocket"></a>3、websocket</h3><p>当然，我们可以参考webpack 和vite的 hmr模式，来自己实现一套基于websocket的hmr功能，来替代上述两个简单粗暴的方案。</p><ol><li>首先我们需要借用vite的插件能力，在vite启动和打包的时候，注入我们的ws代码，并在文件更新后通过ws通道发出需要更新的区域。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;vite-plugin-crx-hmr&#x27;</span>,</span><br><span class="line">  <span class="attr">enforce</span>: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">configResolved</span>(<span class="params">config</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isDev) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isBackground) &#123;</span><br><span class="line">              <span class="comment">// 启动 ws 服务端</span></span><br><span class="line">              <span class="title function_">startWebSocketServer</span>()</span><br><span class="line">          &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">// 链接 ws 服务端</span></span><br><span class="line">              <span class="built_in">setTimeout</span>(connectWebSocketServer, <span class="number">2000</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 打包完成后通知服务端(background)或客户端(page)代码更新</span></span><br><span class="line">  <span class="title function_">closeBundle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;closeBundle&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isDev) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isBackground) &#123;</span><br><span class="line">              <span class="title function_">handleServerChanged</span>()</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="title function_">handleClientChanged</span>(&#123; isPage &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>在background中对ws服务进行链接，建立信号通道。并根据收到的信号量进行不同的reload操作</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hmrWebSocketClient = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(</span><br><span class="line">  <span class="string">`ws://127.0.0.1:<span class="subst">$&#123;crxHmrPort&#125;</span>?mode=background`</span></span><br><span class="line">)</span><br><span class="line">hmrWebSocketClient.<span class="property">onopen</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;background initCrxHmr::&#x27;</span>, <span class="string">&#x27;onopen&#x27;</span>, event)</span><br><span class="line">&#125;</span><br><span class="line">hmrWebSocketClient.<span class="property">onclose</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;background initCrxHmr::&#x27;</span>, <span class="string">&#x27;onclose&#x27;</span>, event)</span><br><span class="line">  hmrWebSocketClient = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hmrWebSocketClient.<span class="property">onmessage</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = e</span><br><span class="line">  <span class="keyword">if</span> (data === <span class="string">&#x27;BACKGROUND_CHANGED&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">      <span class="string">&#x27;background initCrxHmr::&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;收到更新 background.js 消息，关闭 ws 并重新加载&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    hmrWebSocketClient?.<span class="title function_">close</span>()</span><br><span class="line">    chrome.<span class="property">runtime</span>.<span class="title function_">reload</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data === <span class="string">&#x27;IIFE_CHANGED&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">      <span class="string">&#x27;background initCrxHmr::&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;收到更新 iife 消息&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="title function_">reloadIife</span>(hmrWebSocketClient)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data === <span class="string">&#x27;PAGE_CHANGED&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;background initCrxHmr::&#x27;</span>, <span class="string">&#x27;收到更新 page 消息&#x27;</span>)</span><br><span class="line">    <span class="title function_">reloadPage</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>整体流程如下所示</li></ol><p><img src="/images/extension/121730966938_.pic.jpg" alt="分销.png"></p><h3 id="4、-crxjs-vite-plugin"><a href="#4、-crxjs-vite-plugin" class="headerlink" title="4、@crxjs/vite-plugin"></a>4、<a href="https://crxjs.dev/vite-plugin">@crxjs/vite-plugin</a></h3><h3 id="5、rollup-plugin"><a href="#5、rollup-plugin" class="headerlink" title="5、rollup-plugin"></a>5、<a href="https://www.extend-chrome.dev/rollup-plugin">rollup-plugin</a></h3><h1 id="四、成品展示"><a href="#四、成品展示" class="headerlink" title="四、成品展示"></a>四、成品展示</h1><h2 id="无依赖纯手撸版本"><a href="#无依赖纯手撸版本" class="headerlink" title="无依赖纯手撸版本"></a>无依赖纯手撸版本</h2><p><img src="/images/extension/131730966939_.pic.jpg" alt="image.png"></p><h2 id="工具集成版本（仅使用了部分组件库组件-pinia，主要是在开发中可以及时hmr）"><a href="#工具集成版本（仅使用了部分组件库组件-pinia，主要是在开发中可以及时hmr）" class="headerlink" title="工具集成版本（仅使用了部分组件库组件+pinia，主要是在开发中可以及时hmr）"></a>工具集成版本（仅使用了部分组件库组件+pinia，主要是在开发中可以及时hmr）</h2><p><img src="/images/extension/image.GIF" alt="动画.gif"></p><p>从wiki中解析出来后，可以直接复制到代码中进行业务开发。一想到不用挨个复制就美滋滋~😜🥂</p><h1 id="五、尾声"><a href="#五、尾声" class="headerlink" title="五、尾声"></a>五、尾声</h1><p>本文从实践的角度学习了chrome插件的基础知识与使用，同时深入介绍了和前端工具的集成方案，欢迎感兴趣的同事一起学习探讨。</p><hr><p> <strong>done~~</strong>  🏃‍♂️</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上文我们了解了如何实现一个基础版的插件开发。当然，在现代开发模式下，我们肯定不能接受如此简陋的开发模式，那么我们如何进行下一步的优化呢，现在我们继续就如何使用组件库和热更新融合方面进行探索&lt;/p&gt;</summary>
    
    
    
    
    <category term="架构" scheme="https://tauleos.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="Chrome" scheme="https://tauleos.github.io/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>Chrome插件开发</title>
    <link href="https://tauleos.github.io/52dc035aff5e.html"/>
    <id>https://tauleos.github.io/52dc035aff5e.html</id>
    <published>2024-10-25T06:45:09.000Z</published>
    <updated>2024-11-07T07:36:11.984Z</updated>
    
    <content type="html"><![CDATA[<p>chrome浏览器的插件相信大家在日常生活中都会用到，应用市场上的各种插件不仅个性化了我们的浏览器UI设置（比如各种tab页主题设置插件），同时也提供了更为强大的辅助工具。</p><span id="more"></span><blockquote><p>对我们前端来说。用好各种插件也能极大的提升日常工作中的开发效率。那么问题来了。我们如何能够更快更好的使用chrome插件呢？</p></blockquote><p>且听笔者娓娓道来~</p><hr><div class="tip">在日常工作过程中。笔者接到了一个普通的页面开发的需求；仅需要展示一个表格数据即可，当后端的接口文档发给我时，我对着一个表格大约七八十个的字段陷入了沉思😱（我不仅要调整映射，还要把下划线改成驼峰），本着懒癌症晚期患者的原则，我拿起了chrome插件的学习手册。。。</div><h1 id="一、工欲善其事必先利其器"><a href="#一、工欲善其事必先利其器" class="headerlink" title="一、工欲善其事必先利其器"></a>一、工欲善其事必先利其器</h1><h2 id="chrome插件基本介绍"><a href="#chrome插件基本介绍" class="headerlink" title="chrome插件基本介绍"></a>chrome插件基本介绍</h2><ul><li>Manifest （清单文件）</li><li>Service_worker（后台脚本）</li><li>UI Elements （页面元素）</li><li>Content Script （内容脚本）</li></ul><p>整体的结构如下所示：<br><img src="/images/extension/1611729839420_.pic.jpg" alt="结构图"></p><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p>相当于插件的 meta 信息，包含插件的名称、版本号、图标、脚本文件名称等，这个文件是每个插件都必须提供的。</p><p>主要的配置项介绍如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;extract table&quot;</span>, <span class="comment">// 名称</span></span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;An introductory tutorial&quot;</span>, <span class="comment">// 描述</span></span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0&quot;</span>, <span class="comment">// 插件的版本</span></span><br><span class="line">  <span class="string">&quot;manifest_version&quot;</span>: <span class="number">3</span>, <span class="comment">// 清单的版本，目前都是使用 V3</span></span><br><span class="line">  <span class="comment">// action 字段主要描述点击右上角图标弹出的页面</span></span><br><span class="line">  <span class="string">&quot;action&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;default_popup&quot;</span>: <span class="string">&quot;index.html&quot;</span> <span class="comment">// 对应的入口 html 文件（Popup 在后面介绍）</span></span><br><span class="line">    <span class="string">&quot;default_title&quot;</span>: <span class="string">&quot;Garfish Module&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default_icon&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;16&quot;</span>: <span class="string">&quot;favicon.ico&quot;</span>,</span><br><span class="line">      <span class="string">&quot;48&quot;</span>: <span class="string">&quot;favicon.ico&quot;</span>,</span><br><span class="line">      <span class="string">&quot;128&quot;</span>: <span class="string">&quot;favicon.ico&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">// 需要使用一些特殊 API 时需要在 permissions 声明权限，会提示给用户</span></span><br><span class="line">  <span class="string">&quot;permissions&quot;</span>: [<span class="string">&quot;storage&quot;</span>, <span class="string">&quot;scripting&quot;</span>],</span><br><span class="line">  <span class="comment">// 哪些域名允许使用插件</span></span><br><span class="line">  <span class="string">&quot;host_permissions&quot;</span>: [<span class="string">&quot;&lt;all_urls&gt;&quot;</span>],</span><br><span class="line">  <span class="comment">// 声明 background service worker 的路径，在后面介绍</span></span><br><span class="line">  <span class="string">&quot;background&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;service_worker&quot;</span>: <span class="string">&quot;background.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 声明 content script 的入口文件路径、允许使用的域名以及执行时机</span></span><br><span class="line">  <span class="string">&quot;content_scripts&quot;</span>: [&#123;</span><br><span class="line">    <span class="string">&quot;js&quot;</span>: [<span class="string">&quot;content.js&quot;</span>]</span><br><span class="line">    <span class="string">&quot;matches&quot;</span>: [<span class="string">&quot;&lt;all_urls&gt;&quot;</span>],</span><br><span class="line">    <span class="comment">//  &quot;document_start&quot; &quot;document_idle&quot; &quot;document_end&quot; 三个值</span></span><br><span class="line">    <span class="string">&quot;run_at&quot;</span>: <span class="string">&quot;document_idle&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service-worker（后台脚本）"><a href="#Service-worker（后台脚本）" class="headerlink" title="Service_worker（后台脚本）"></a>Service_worker（后台脚本）</h2><p>manifest v2中称之为<code>background script</code>,v3统一成 service_worker.</p><p>可以调用全部的 chrome 插件 API，实现跨域请求、网页截屏、弹出 chrome 通知消息等功能。插件激活后会在浏览器后台默默运行。</p><h2 id="UI-Elements-（页面元素）"><a href="#UI-Elements-（页面元素）" class="headerlink" title="UI Elements （页面元素）"></a>UI Elements （页面元素）</h2><p> 主要包括点击插件的弹出框（popup）、插件的配置页（optons）,插入到控制台的tab页等等。</p><h2 id="Content-Script-（内容脚本）"><a href="#Content-Script-（内容脚本）" class="headerlink" title="Content Script （内容脚本）"></a>Content Script （内容脚本）</h2><p>是插件注入到页面的脚本，但是不会体现在页面 DOM 结构里。在一个单独的沙盒内运行，可以操作页面的DOM、调用有限的插件API等。</p><h2 id="页面通信"><a href="#页面通信" class="headerlink" title="页面通信"></a>页面通信</h2><blockquote><p>由于content_scripts是在网页中运行的，而非在扩展的上下文中，因此它们通常需要某种方式与扩展的其余部分进行通信。extensions 和content_scripts之间的通信通过使用消息传递进行。 任何一方都可以侦听从另一端发送的消息，并在同一通道上做出响应。</p></blockquote><h3 id="从content-scripts发送消息的代码如下所示："><a href="#从content-scripts发送消息的代码如下所示：" class="headerlink" title="从content_scripts发送消息的代码如下所示："></a>从content_scripts发送消息的代码如下所示：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> chrome.<span class="property">runtime</span>.<span class="title function_">sendMessage</span>(&#123;<span class="attr">greeting</span>: <span class="string">&quot;hello&quot;</span>&#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="从【options-page-bakcground-popup】等位置发送到-content-scripts的-代码示例"><a href="#从【options-page-bakcground-popup】等位置发送到-content-scripts的-代码示例" class="headerlink" title="从【options_page,bakcground,popup】等位置发送到 content_scripts的 代码示例:"></a>从【options_page,bakcground,popup】等位置发送到 content_scripts的 代码示例:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [tab] = <span class="keyword">await</span> chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">lastFocusedWindow</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> chrome.<span class="property">tabs</span>.<span class="title function_">sendMessage</span>(tab.<span class="property">id</span>, &#123;<span class="attr">greeting</span>: <span class="string">&quot;hello&quot;</span>&#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="通过runtime-onMessage事件侦听器来处理消息"><a href="#通过runtime-onMessage事件侦听器来处理消息" class="headerlink" title="通过runtime.onMessage事件侦听器来处理消息"></a>通过runtime.onMessage事件侦听器来处理消息</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sender.<span class="property">tab</span> ? <span class="string">&quot;from a content script:&quot;</span> + sender.<span class="property">tab</span>.<span class="property">url</span> :<span class="string">&quot;from the extension&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="property">greeting</span> === <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">      <span class="title function_">sendResponse</span>(&#123;<span class="attr">farewell</span>: <span class="string">&quot;goodbye&quot;</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>除此之外，插件还提供了长连接来实现通信。</p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>修改了devtools页面的代码时，需要先在 扩展程序页面下重新加载插件，然后关闭再打开开发者工具即可，无需刷新页面。</p><h1 id="二、牛刀小试"><a href="#二、牛刀小试" class="headerlink" title="二、牛刀小试"></a>二、牛刀小试</h1><h2 id="首先创建好我们的项目文件，设置好我们需要的配置"><a href="#首先创建好我们的项目文件，设置好我们需要的配置" class="headerlink" title="首先创建好我们的项目文件，设置好我们需要的配置"></a>首先创建好我们的项目文件，设置好我们需要的配置</h2><p><img src="/images/extension/1621729839421_.pic.jpg" alt="image.png"></p><h2 id="在popup中实现界面的绘制和按钮事件的绑定"><a href="#在popup中实现界面的绘制和按钮事件的绑定" class="headerlink" title="在popup中实现界面的绘制和按钮事件的绑定"></a>在popup中实现界面的绘制和按钮事件的绑定</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> targetDom = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;targetDom&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> columnKey = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;clickBtn&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> result = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#result&#x27;</span>);</span><br><span class="line"><span class="comment">//发送dom给content去解析</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="title function_">async</span> ()=&gt;&#123;</span><br><span class="line">  <span class="keyword">var</span> classname = targetDom.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">if</span>(classname)&#123;</span><br><span class="line">    selector = classname.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">i</span>=&gt;</span><span class="string">`.<span class="subst">$&#123;i&#125;</span>`</span>).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123;<span class="attr">active</span>:<span class="literal">true</span>,<span class="attr">currentWindow</span>:<span class="literal">true</span>&#125;,<span class="function">(<span class="params">tabs</span>)=&gt;</span>&#123;</span><br><span class="line">      chrome.<span class="property">tabs</span>.<span class="title function_">sendMessage</span>(tabs[<span class="number">0</span>].<span class="property">id</span>,&#123;selector,columnKey&#125;,<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;response&#x27;</span>,res);</span><br><span class="line">        result.<span class="property">innerText</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res,<span class="literal">null</span>,<span class="number">4</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="在content-scripts中接收参数并完成dom结构解析，最终把数据返回给popup送显。"><a href="#在content-scripts中接收参数并完成dom结构解析，最终把数据返回给popup送显。" class="headerlink" title="在content_scripts中接收参数并完成dom结构解析，最终把数据返回给popup送显。"></a>在content_scripts中接收参数并完成dom结构解析，最终把数据返回给popup送显。</h2><p>这样我们就完成了一个基础版的插件开发。当然，在现代开发模式下，我们肯定不能接受如此简陋的开发模式，那么我们如何进行下一步的优化呢，我们下篇继续~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;chrome浏览器的插件相信大家在日常生活中都会用到，应用市场上的各种插件不仅个性化了我们的浏览器UI设置（比如各种tab页主题设置插件），同时也提供了更为强大的辅助工具。&lt;/p&gt;</summary>
    
    
    
    
    <category term="架构" scheme="https://tauleos.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="Chrome" scheme="https://tauleos.github.io/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>TS中includes等API不识别坑</title>
    <link href="https://tauleos.github.io/db04494e7d11.html"/>
    <id>https://tauleos.github.io/db04494e7d11.html</id>
    <published>2022-03-10T07:08:33.000Z</published>
    <updated>2024-11-06T08:27:08.635Z</updated>
    
    <content type="html"><![CDATA[<p>最近基础库线上遇到一个很奇怪的问题，用户在<code>android 5.0</code>浏览器上访问引入基础库的页面时直接报错，错误信息是经典的<code>&quot;Can not read property xxx of undefined&quot;</code>错误。经过分析调研发现是因为项目中使用了<code>Array.prototype.includes</code>导致。定位到问题后优先加了<code>polyfill</code>解决线上问题.<br>事后调研为什么会发生这样的问题，最终结论如下：</p><blockquote><p>typescript本身的编译工具只会对所谓的语法（也就是<code>syntax</code>）进行转换，以匹配<code>tsconfig.json</code> 中的<code>target</code>选项，而对于<code>es6/7/8</code>中新出现的<code>API</code>,比如<code>Array.prototype.includes</code>,<code>Object.values</code>等方法，<code>typescript</code> 并不会进行转换。</p></blockquote><p>ts代码</p><p><img src="/images/ts-api/before.png"></p><p>编译后代码<br><img src="/images/ts-api/after.png"></p><h2 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h2><blockquote><p><code>typescript</code>本身是静态检查工具，它不会在运行时根据代码所运行的环境再自动<code>polyfill</code>;它只是假定你本身项目所运行的环境是<code>tsconfig</code>的<code>lib</code>属性指定的环境。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近基础库线上遇到一个很奇怪的问题，用户在&lt;code&gt;android 5.0&lt;/code&gt;浏览器上访问引入基础库的页面时直接报错，错误信息是经典的&lt;code&gt;&amp;quot;Can not read property xxx of undefined&amp;quot;&lt;/code&gt;错</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从零打造装饰器风格的NodeJs路由器</title>
    <link href="https://tauleos.github.io/f559cd027a92.html"/>
    <id>https://tauleos.github.io/f559cd027a92.html</id>
    <published>2022-03-10T06:43:44.000Z</published>
    <updated>2024-11-06T08:27:08.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文章默认听众使用Koa框架。</p></blockquote><p>在我们使用nodejs开发项目的时候，如果项目中有很多路由，那么我们需要写很多的类似<code>router.get(&#39;xxx&#39;, () =&gt; &#123;&#125;)</code>这样的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line">router</span><br><span class="line">  .<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">post</span>(<span class="string">&#x27;/users&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">put</span>(<span class="string">&#x27;/users/:id&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>熟悉<code>Java</code>的朋友应该都知道， 可以通过以下形式定义路由</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/list&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/update&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样不仅简化、规范化了路由的写法，减少了代码的冗余和错误，还使代码含义一目了然，无需注释也能通俗易懂。那么<code>Java</code>中的注解功能对应到<code>NodeJs</code>，分别是一下两种工具：<strong>装饰器与元编程</strong>。我们是不是也可以通过装饰器来达到我们的目的呢?首先让我们先来了解一下他们。</p><h2 id="Decorator-装饰器"><a href="#Decorator-装饰器" class="headerlink" title="Decorator(装饰器)"></a>Decorator(装饰器)</h2><p>装饰器提供了一种为类声明和成员添加注释和元编程语法的方法。装饰器是<code>JavaScript</code>的<a href="https://github.com/tc39/proposal-decorators">stage-2 proposal</a>，可作为 <code>TypeScript</code> 的实验性功能使用。</p><blockquote><p>注意装饰器是一项实验性功能，可能会在未来版本中更改。</p></blockquote><p>要启用对装饰器的实验性支持，必须要在<code>tsconfig.json</code>中配置打开<code>experimentalDecorators</code>这个编译属性<br><img src="/images/decorator/ts-definition.png"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; &#123;</span><br><span class="line">    enumerable?: <span class="built_in">boolean</span>;</span><br><span class="line">    configurable?: <span class="built_in">boolean</span>;</span><br><span class="line">    writable?: <span class="built_in">boolean</span>;</span><br><span class="line">    value?: T;</span><br><span class="line">    get?: <span class="function">() =&gt;</span> T;</span><br><span class="line">    set?: <span class="function">(<span class="params"><span class="attr">value</span>: T</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">ClassDecorator</span> = &lt;<span class="title class_">TFunction</span> <span class="keyword">extends</span> <span class="title class_">Function</span>&gt;<span class="function">(<span class="params"><span class="attr">target</span>: <span class="title class_">TFunction</span></span>) =&gt;</span> <span class="title class_">TFunction</span> | <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">PropertyDecorator</span> = <span class="function">(<span class="params"><span class="attr">target</span>: <span class="title class_">Object</span>, <span class="attr">propertyKey</span>: <span class="built_in">string</span> | <span class="built_in">symbol</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">MethodDecorator</span> = &lt;T&gt;<span class="function">(<span class="params"><span class="attr">target</span>: <span class="title class_">Object</span>, <span class="attr">propertyKey</span>: <span class="built_in">string</span> | <span class="built_in">symbol</span>, <span class="attr">descriptor</span>: <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt;</span>) =&gt;</span> <span class="title class_">TypedPropertyDescriptor</span>&lt;T&gt; | <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">type</span> <span class="title class_">ParameterDecorator</span> = <span class="function">(<span class="params"><span class="attr">target</span>: <span class="title class_">Object</span>, <span class="attr">propertyKey</span>: <span class="built_in">string</span> | <span class="built_in">symbol</span>, <span class="attr">parameterIndex</span>: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol><li>不同类型的装饰器的执行顺序是明确定义的：</li><li>实例成员:    参数装饰器 -&gt; 方法 / 访问器 / 属性 装饰器</li><li>静态成员:    参数装饰器 -&gt; 方法 / 访问器 / 属性 装饰器</li><li>构造器:        参数装饰器</li><li>类装饰器</li><li>同一方法中不同参数的装饰器的执行顺序是相反的， <strong>最后一个参数的装饰器会最先被执行</strong></li><li>多个装饰器组合应用，他们的执行顺序是<strong>由上到下编译，由下到上执行（FILO）,可以当做栈来理解</strong></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">key: string</span>): any &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;evaluate: &quot;</span>, key);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;call: &quot;</span>, key);</span><br><span class="line">  &#125;;&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title function_">f</span>(<span class="string">&quot;Class Decorator&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  @<span class="title function_">f</span>(<span class="string">&quot;Static Property&quot;</span>)</span><br><span class="line">  <span class="keyword">static</span> prop?: number;</span><br><span class="line"></span><br><span class="line">  @<span class="title function_">f</span>(<span class="string">&quot;Static Method&quot;</span>)</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">method</span>(<span class="params">@f(<span class="string">&quot;Static Method Parameter&quot;</span>) foo</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">@f(<span class="string">&quot;Constructor Parameter&quot;</span>) foo</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title function_">f</span>(<span class="string">&quot;Instance Method&quot;</span>)</span><br><span class="line">  <span class="title function_">method</span>(<span class="params">@f(<span class="string">&quot;Instance Method Parameter&quot;</span>) foo</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title function_">f</span>(<span class="string">&quot;Instance Property&quot;</span>)</span><br><span class="line">  prop?: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reflect-metadata-元数据"><a href="#reflect-metadata-元数据" class="headerlink" title="reflect-metadata(元数据)"></a><a href="https://github.com/rbuckton/reflect-metadata">reflect-metadata</a>(元数据)</h2><blockquote><p>严格地说，元数据和装饰器是<code>EcmaScript</code>中两个独立的部分。 然而，如果你想实现像是<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">反射</a>这样的能力，你总是同时需要它们。<br>有了<code>reflect-metadata</code>的帮助， 我们可以获取编译期的类型。</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>Reflect Metadata</code> 是 ES7 的一个提案（stage-2），它主要用来在声明的时候添加和读取元数据。<code>TypeScript</code> 在 1.5+ 的版本已经支持它，你只需要：</p><ul><li><code>npm i reflect-metadata --save</code></li><li>在 <code>tsconfig.json</code> 里配置 <code>emitDecoratorMetadata</code> 选项。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@<span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)<span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  @<span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>)</span><br><span class="line">  public <span class="title function_">hello</span>(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;name&#x27;</span>, A) <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="keyword">new</span> <span class="title function_">A</span>()) <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// define metadata on an object or property</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(metadataKey, metadataValue, target);</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(metadataKey, metadataValue, target, propertyKey);</span><br><span class="line"><span class="comment">// check for presence of a metadata key on the prototype chain of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">hasMetadata</span>(metadataKey, target);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">hasMetadata</span>(metadataKey, target, propertyKey);</span><br><span class="line"><span class="comment">// check for presence of an own metadata key of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">hasOwnMetadata</span>(metadataKey, target);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">hasOwnMetadata</span>(metadataKey, target, propertyKey);</span><br><span class="line"><span class="comment">// get metadata value of a metadata key on the prototype chain of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(metadataKey, target);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(metadataKey, target, propertyKey);</span><br><span class="line"><span class="comment">// get metadata value of an own metadata key of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">getOwnMetadata</span>(metadataKey, target);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">getOwnMetadata</span>(metadataKey, target, propertyKey);</span><br><span class="line"><span class="comment">// get all metadata keys on the prototype chain of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">getMetadataKeys</span>(target);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">getMetadataKeys</span>(target, propertyKey);</span><br><span class="line"><span class="comment">// get all own metadata keys of an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">getOwnMetadataKeys</span>(target);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">getOwnMetadataKeys</span>(target, propertyKey);</span><br><span class="line"><span class="comment">// delete metadata from an object or property</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteMetadata</span>(metadataKey, target);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteMetadata</span>(metadataKey, target, propertyKey);</span><br><span class="line"><span class="comment">// apply metadata via a decorator to a constructor</span></span><br><span class="line">@<span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(metadataKey, metadataValue)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="comment">// apply metadata via a decorator to a method (property)</span></span><br><span class="line">  @<span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(metadataKey, metadataValue)</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何用装饰器打造路由？"><a href="#如何用装饰器打造路由？" class="headerlink" title="如何用装饰器打造路由？"></a>如何用装饰器打造路由？</h2><p><img src="/images/decorator/effects.png"></p><ol><li>提供需要注册的装饰器,通过<code>metadata</code>存储对应的数据信息。 </li><li>类装饰器：<code>@Controller()</code><br><img src="/images/decorator/controller.png"></li><li>方法装饰器：<code>@Get()、@Post()、@Put()、@Delete()</code><br><img src="/images/decorator/method.png"></li><li>参数装饰器：<code>@Request()、@Response()、@Ctx()、@Body()、@Param()、@Session()</code>等等。<br><img src="/images/decorator/param.png"></li><li>创建一个依赖注入的容器，收集所有与路由相关的配置，并进行路由注册。</li><li>遍历文件夹中所有符合条件的Controller文件，并获取相应的Controller类<br><img src="/images/decorator/scan.png"></li><li>扫描每个Controller类的实例方法，检测是否需要路由注册，并根据metadata中的数据进行路由的组装与注册<br><img src="/images/decorator/register.png"></li><li>绑定Controller实例方法到KoaRouter中，并注入相关参数。<br><img src="/images/decorator/callback.png"></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在项目启动阶段，会创建一个依赖注入容器（<code>Container</code>），扫描所有用户代码（<code>Controller</code>）中的文件，将拥有<code>@Controller</code>装饰器的 <code>Class</code>，保存到容器中。</li><li>这里的依赖注入容器内部维护了一个数组。用来存放类本身。</li><li>在扫描时，会动态实例化这些 Class，并且绑定属性方法（参数）与路由的动态关系，并且注册到router中</li></ul><p>以上就是路由器注入的核心过程。</p><h2 id="场景扩展"><a href="#场景扩展" class="headerlink" title="场景扩展"></a>场景扩展</h2><ul><li>Before/After钩子。</li><li>监听属性改变或者方法调用。</li><li>对方法的参数做转换。</li><li>添加额外的方法和属性。</li><li>运行时类型检查。</li><li>依赖注入（dependency injection）</li></ul><p>参考资料</p><ul><li><a href="https://www.typescriptlang.org/docs/handbook/decorators.html#introduction">https://www.typescriptlang.org/docs/handbook/decorators.html#introduction</a></li><li><a href="https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator">https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator</a></li><li><a href="https://rbuckton.github.io/reflect-metadata/">https://rbuckton.github.io/reflect-metadata/</a></li><li><a href="https://github.com/seanpmaxwell/overnight">https://github.com/seanpmaxwell/overnight</a></li><li><a href="https://nestjs.com/">https://nestjs.com/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文章默认听众使用Koa框架。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我们使用nodejs开发项目的时候，如果项目中有很多路由，那么我们需要写很多的类似&lt;code&gt;router.get(&amp;#39;xxx&amp;#39;, () =&amp;gt; &amp;#12</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何解决微前端中的路由跳转坑</title>
    <link href="https://tauleos.github.io/effa4f74d0af.html"/>
    <id>https://tauleos.github.io/effa4f74d0af.html</id>
    <published>2022-03-10T03:37:28.000Z</published>
    <updated>2024-11-06T08:27:08.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><blockquote><p>商家工作台目前已经使用<a href="https://qiankun.umijs.org/">qiankun</a> 改造成微前端体系，微前端的好处不用我赘述，大家懂的都懂，因此在有品二清项目开发时也以微前端的方式进行接入。在送测过程中，测试同学反馈在点击浏览器回退的时候会页面空白，我一脸蒙圈的试了好几次却没复现，最终在服务端同学跟测试同学的大力配合下，找到了稳定复现的场景。</p></blockquote><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><blockquote><p>When you have eliminated the impossibles,whatever remains,however improbable,must be the truth.     – 福尔摩斯</p></blockquote><div class='tip'>为什么会出现这个问题呢？<p style="text-indent:20em;">原因未知，需要继续拆解</p>以前接入过的子应用有遇到过这种问题呢？<p style="text-indent:20em;">就我所知没有</p>好的，为什么以前的子应用没有遇到过呢？<p style="text-indent:20em;">因为以前的子应用跟主应用都是vue2的router</p>那就是说可能是新旧Router导致的咯？  <p style="text-indent:20em;">有可能哦~问问其他子应用呢</p>.....问过了，人家是好的<p style="text-indent:20em;">      ？？？？.....再报再探！</p></div><hr><p>以上是遇到问题时混乱的大脑的疑点闪现过程。从中我们不难找出导致问题的大致范围：<strong>主应用的Router版本与子应用的Router版本不一致</strong>，当然，中间还存在几个疑点，需要继续拨开迷雾。</p><ol><li>实现原理有什么差异会导致这个问题。</li><li>其他<code>Vue3</code>项目为啥没遇到这个问题。</li></ol><p>带着以上问题，我们开始进入漫长的断点debug 与翻源码过程。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><blockquote><p>真実はいつもひとつ</p></blockquote><h3 id="1-实现原理的差异"><a href="#1-实现原理的差异" class="headerlink" title="1. 实现原理的差异"></a>1. 实现原理的差异</h3><p>首先，让我们来分析一波新旧版本的 <code>Router</code> 到底更改了什么。<br>我们在新版本<code>Router</code>文档中找到这么一段说明。<br><img src="/images/qiankun-router/history-state.png" alt="history.state"></p><p>稍后我们会在源码中找到对应的操作<code>state</code>的具体位置<br>而旧版本的<code>Router</code>使用的<code>pushState</code>，则只在<code>state</code>中存储了key这唯一一个属性。(<code>vue-router/src/util/push-state.js</code>)<br><img src="/images/qiankun-router/pushState.png" alt="history.state"></p><div class="tip">也就是说，<code>history.state</code> 在新旧版本的<code>Router</code>中的数据结构是不一致的。</div><p>我猜这应该是导致改问题的<strong>核心因素</strong>了。我们接着往下验证</p><h3 id="2-undefined-的由来"><a href="#2-undefined-的由来" class="headerlink" title="2. undefined 的由来"></a>2. undefined 的由来</h3><ol><li><p>主应用在点击左侧菜单的时候，会触发<code>pushState</code>,从而激活子应用，进入子应用对应的菜单中。<br><img src="/images/qiankun-router/main-pushState.png" alt="history.state"></p></li><li><p>子应用在第一次进入的时候，会执行<code>changeLocation</code>的<code>replace</code>操作，此时页面进入子应用内。</p></li><li><p>子应用内部页面跳转时，所有的路由均由子应用<code>Router</code>进行接管。此时一切正常。</p></li><li><p>再次点击主应用左侧菜单时，执行以下代码<strong>将 history.state 置为空对象。</strong>同时，页面跳转到对应路由页面。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.<span class="title function_">pushState</span>(&#123;&#125;, <span class="string">&#x27;&#x27;</span>, jumpUrl)</span><br></pre></td></tr></table></figure></li><li><p>继续在子应用内部跳转路由时，如下图所示，当执行到 <code>push(vue-router/history/html5.ts)</code> 的时候，由于此时 <code>history.state</code> 已经变成了空对象，所以图中的 <code>currentState.current</code> 就变成了<code>undefined</code>。</p><blockquote><p>在265行会先调用一次<code>changeLocation</code>用来记录当前路由信息(中间状态)</p></blockquote></li></ol><p><img src="/images/qiankun-router/push.png" alt="history.state"></p><ol start="6"><li>而进入到 <code>changeLocation</code> 方法内部，此时的 <code>to</code> 已经变成了<code>undefined</code>，也因此拼装的 <code>url</code> 中会出现<code>undefined</code>。<br><img src="/images/qiankun-router/changelocation.png" alt="history.state"></li><li>由于第六步中执行的是中间态的记录当前路由行为，后续还会继续跳转真实的目的地路由，所以中间态的<code>undefined</code>被保存在了浏览器的路由栈中。当触发回退的时候，就跳到了<code>url</code>中带有<code>undefined</code>resole的空白页面。</li><li>现在，案情真相大白了。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><img src="/images/qiankun-router/resolve.png" alt="history.state"></p><p>一劳永逸的方案则是：主应用与子应用均使用同一个版本的 <code>VueRouter</code>,当然，也要从实际出发，综合考虑各项改动的<code>ROI</code>，从而采用更合理的方案。</p><h2 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing!"></a>One More Thing!</h2><div class="tip">为什么其他使用新Router的子应用没有遇到同样的问题？</div>我盲猜是因为 其他子应用要么只有一个主应用的菜单，要么子应用之间的菜单比较独立，所以没有遇到。实际上，这应该是个必现的场景。]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件背景&quot;&gt;&lt;a href=&quot;#事件背景&quot; class=&quot;headerlink&quot; title=&quot;事件背景&quot;&gt;&lt;/a&gt;事件背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;商家工作台目前已经使用&lt;a href=&quot;https://qiankun.umijs.org/&quot;&gt;q</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>阿里一面整理</title>
    <link href="https://tauleos.github.io/58bedbf90157.html"/>
    <id>https://tauleos.github.io/58bedbf90157.html</id>
    <published>2021-01-28T03:15:23.000Z</published>
    <updated>2024-11-06T08:27:08.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><p>参考之前的文章-<a href="./4c84e4a4db9d.html">阿里笔试题收集</a></p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h3 id="说一下自己熟悉的技术栈"><a href="#说一下自己熟悉的技术栈" class="headerlink" title="说一下自己熟悉的技术栈"></a>说一下自己熟悉的技术栈</h3><p>因为我主要列举了node,ts,vue这三个，所以下边的问题大多围绕着这几个来展开</p><h3 id="1、vue里批量更新的机制"><a href="#1、vue里批量更新的机制" class="headerlink" title="1、vue里批量更新的机制"></a>1、vue里批量更新的机制</h3><h3 id="2、介绍下浏览器的EventLoop，Node端的EventLoop"><a href="#2、介绍下浏览器的EventLoop，Node端的EventLoop" class="headerlink" title="2、介绍下浏览器的EventLoop，Node端的EventLoop"></a>2、介绍下浏览器的EventLoop，Node端的EventLoop</h3><h3 id="3、vuex有使用过吗，使用场景是怎样的"><a href="#3、vuex有使用过吗，使用场景是怎样的" class="headerlink" title="3、vuex有使用过吗，使用场景是怎样的"></a>3、vuex有使用过吗，使用场景是怎样的</h3><h3 id="4、vue中的组件通信方式"><a href="#4、vue中的组件通信方式" class="headerlink" title="4、vue中的组件通信方式"></a>4、vue中的组件通信方式</h3><h3 id="5、Node中常用的模块有哪些，有用过cluster吗？介绍下cluter"><a href="#5、Node中常用的模块有哪些，有用过cluster吗？介绍下cluter" class="headerlink" title="5、Node中常用的模块有哪些，有用过cluster吗？介绍下cluter"></a>5、Node中常用的模块有哪些，有用过cluster吗？介绍下cluter</h3><h3 id="6、cluster中是如何做到监听一个端口不报错的"><a href="#6、cluster中是如何做到监听一个端口不报错的" class="headerlink" title="6、cluster中是如何做到监听一个端口不报错的"></a>6、cluster中是如何做到监听一个端口不报错的</h3><h3 id="7、进程间通信你还知道哪些方式"><a href="#7、进程间通信你还知道哪些方式" class="headerlink" title="7、进程间通信你还知道哪些方式"></a>7、进程间通信你还知道哪些方式</h3><h3 id="8、计算机网络的知识了解的多吗？OSI七层模型里，http，tcp，ip分别对应的是哪一层"><a href="#8、计算机网络的知识了解的多吗？OSI七层模型里，http，tcp，ip分别对应的是哪一层" class="headerlink" title="8、计算机网络的知识了解的多吗？OSI七层模型里，http，tcp，ip分别对应的是哪一层"></a>8、计算机网络的知识了解的多吗？OSI七层模型里，http，tcp，ip分别对应的是哪一层</h3><h3 id="9、可以说一下https的原理吗？https为什么是安全的"><a href="#9、可以说一下https的原理吗？https为什么是安全的" class="headerlink" title="9、可以说一下https的原理吗？https为什么是安全的"></a>9、可以说一下https的原理吗？https为什么是安全的</h3><h3 id="10、https的证书还有其他的什么作用？"><a href="#10、https的证书还有其他的什么作用？" class="headerlink" title="10、https的证书还有其他的什么作用？"></a>10、https的证书还有其他的什么作用？</h3><h3 id="11、有发布过npm包吗？npm包的开发上线流程是怎样的"><a href="#11、有发布过npm包吗？npm包的开发上线流程是怎样的" class="headerlink" title="11、有发布过npm包吗？npm包的开发上线流程是怎样的"></a>11、有发布过npm包吗？npm包的开发上线流程是怎样的</h3><h3 id="12、能描述一下你之前做过的技术亮点或者业务亮点吗？"><a href="#12、能描述一下你之前做过的技术亮点或者业务亮点吗？" class="headerlink" title="12、能描述一下你之前做过的技术亮点或者业务亮点吗？"></a>12、能描述一下你之前做过的技术亮点或者业务亮点吗？</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;笔试&quot;&gt;&lt;a href=&quot;#笔试&quot; class=&quot;headerlink&quot; title=&quot;笔试&quot;&gt;&lt;/a&gt;笔试&lt;/h2&gt;&lt;p&gt;参考之前的文章-&lt;a href=&quot;./4c84e4a4db9d.html&quot;&gt;阿里笔试题收集&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;面试&quot;&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>阿里笔试题收集-1</title>
    <link href="https://tauleos.github.io/4c84e4a4db9d.html"/>
    <id>https://tauleos.github.io/4c84e4a4db9d.html</id>
    <published>2020-11-05T06:56:40.000Z</published>
    <updated>2024-11-06T08:27:08.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、另类排序"><a href="#一、另类排序" class="headerlink" title="一、另类排序"></a>一、另类排序</h2><p>题目：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 排序后输出 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array&lt;Object&gt;</span>&#125; <span class="variable">list</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Array&lt;number&gt;</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> *  &#123; id: 2, before: 1 &#125;,</span></span><br><span class="line"><span class="comment"> *  &#123; id: 1, last: true &#125;,</span></span><br><span class="line"><span class="comment"> *  &#123; id: 3, after: 1 &#125;,</span></span><br><span class="line"><span class="comment"> *  &#123; id: 5, first: true &#125;,</span></span><br><span class="line"><span class="comment"> *  &#123; id: 6, last: true &#125;,</span></span><br><span class="line"><span class="comment"> *  &#123; id: 7, last: true &#125;,</span></span><br><span class="line"><span class="comment"> *  &#123; id: 8, last: true &#125;,</span></span><br><span class="line"><span class="comment"> * ];</span></span><br><span class="line"><span class="comment"> * 输出为</span></span><br><span class="line"><span class="comment"> * [5, 2, 1, 3, 6, 7, 8];</span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> * &#123; id: 2, before: 3 &#125;,</span></span><br><span class="line"><span class="comment"> *&#123; id: 1, before: 2 &#125;,</span></span><br><span class="line"><span class="comment"> *&#123; id: 3, before: 5 &#125;,</span></span><br><span class="line"><span class="comment"> *  &#123; id: 5, before: 6 &#125;,</span></span><br><span class="line"><span class="comment"> *&#123; id: 6, last: true &#125;,</span></span><br><span class="line"><span class="comment"> * &#123; id: 7, last: true &#125;,</span></span><br><span class="line"><span class="comment"> * &#123; id: 8, last: true &#125;,</span></span><br><span class="line"><span class="comment"> * ];</span></span><br><span class="line"><span class="comment"> * 输出：</span></span><br><span class="line"><span class="comment"> * [1,2,3,5,6,7,8]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>解法1：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">source, target = []</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (source.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> current = source.<span class="title function_">shift</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; id, before, after, first, last  &#125; = current</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">      target.<span class="title function_">unshift</span>(id)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (last) &#123;</span><br><span class="line">      target.<span class="title function_">push</span>(id)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 前后关系处理，找到对应的index，如果对应的目标未入盏则放到最后进行处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&#x27;before&#x27;</span> <span class="keyword">in</span> current || <span class="string">&#x27;after&#x27;</span> <span class="keyword">in</span> current) &#123;</span><br><span class="line">      <span class="keyword">const</span> targetId = before || after</span><br><span class="line">      <span class="keyword">const</span> index = target.<span class="title function_">findIndex</span>(<span class="function"><span class="params">value</span> =&gt;</span> value === targetId)</span><br><span class="line">      <span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * source 和 target都不存在目标id的情况下，直接插入</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="keyword">if</span> (source.<span class="title function_">find</span>(<span class="function"><span class="params">value</span> =&gt;</span> value === targetId)) &#123;</span><br><span class="line">              source.<span class="title function_">push</span>(current)</span><br><span class="line">              <span class="keyword">return</span> <span class="title function_">sort</span>(source, target)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              target.<span class="title function_">push</span>(id)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          target.<span class="title function_">splice</span>(<span class="string">&#x27;before&#x27;</span> <span class="keyword">in</span> current ? index : index + <span class="number">1</span>, <span class="number">0</span>, id)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">sort</span>(source, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">function parse(list) &#123;</span><br><span class="line">  <span class="built_in">let</span> result = [];</span><br><span class="line">  <span class="built_in">let</span> filtered = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">let</span> i of list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i.<span class="built_in">first</span>)&#123;</span><br><span class="line">      result.unshift(i.id);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i.<span class="built_in">last</span>)&#123;</span><br><span class="line">      result.<span class="built_in">push</span>(i.id);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      filtered.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(filtered.<span class="built_in">length</span>)&#123;</span><br><span class="line">    <span class="built_in">let</span> cur = filtered.shift();</span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">key</span> = cur.before ? cur.before : cur.after;</span><br><span class="line">    <span class="built_in">let</span> index = result.findIndex(i=&gt;i===<span class="built_in">key</span>);</span><br><span class="line">    <span class="keyword">if</span>(index !== -<span class="number">1</span>)&#123;</span><br><span class="line">      result.<span class="built_in">splice</span>(cur.before ? index: index+<span class="number">1</span>,<span class="number">0</span>,cur.id);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      filtered.<span class="built_in">push</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、二维数组转树状结构"><a href="#二、二维数组转树状结构" class="headerlink" title="二、二维数组转树状结构"></a>二、二维数组转树状结构</h2><p>题目：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2. 将数组转换成树状结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">arr</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Object</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * [</span></span><br><span class="line"><span class="comment"> *   &#123; id: 1, name: &#x27;i1&#x27; &#125;,</span></span><br><span class="line"><span class="comment"> *   &#123; id: 2, name: &#x27;i2&#x27;, parentId: 1 &#125;,</span></span><br><span class="line"><span class="comment"> *   &#123; id: 4, name: &#x27;i4&#x27;, parentId: 3 &#125;,</span></span><br><span class="line"><span class="comment"> *   &#123; id: 3, name: &#x27;i3&#x27;, parentId: 2 &#125;,</span></span><br><span class="line"><span class="comment"> *   &#123; id: 8, name: &#x27;i8&#x27;, parentId: 7 &#125;,</span></span><br><span class="line"><span class="comment"> * ]</span></span><br><span class="line"><span class="comment"> * 转换后</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   id: 1,</span></span><br><span class="line"><span class="comment"> *   name: &#x27;i1&#x27;,</span></span><br><span class="line"><span class="comment"> *   children: [</span></span><br><span class="line"><span class="comment"> *     &#123; id: 2, name: &#x27;i2&#x27;, parentId: 1, children: [...] &#125;,</span></span><br><span class="line"><span class="comment"> *   ]</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convert2Tree</span>(<span class="params">arr</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> parentMap = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> root;</span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a.<span class="property">id</span>-b.<span class="property">id</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> node <span class="keyword">of</span> arr)&#123;</span><br><span class="line">node.<span class="property">children</span> = [];</span><br><span class="line"><span class="keyword">if</span>(!node.<span class="property">parentId</span>)&#123;</span><br><span class="line"></span><br><span class="line">root = node;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">let</span> parent = parentMap[node.<span class="property">parentId</span>];</span><br><span class="line"><span class="keyword">if</span>(parent)&#123;</span><br><span class="line">parent.<span class="property">children</span>.<span class="title function_">push</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">parentMap[node.<span class="property">id</span>] = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、用setTimeout实现setInterval"><a href="#三、用setTimeout实现setInterval" class="headerlink" title="三、用setTimeout实现setInterval"></a>三、用setTimeout实现setInterval</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. 实现 setInterval</span></span><br><span class="line"><span class="comment"> * 利用 setTimeout 实现 setInterval</span></span><br><span class="line"><span class="comment"> * 利用 clearTimeout 实现 clearInterval</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; <span class="variable">callback</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">duration</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * mySetInterval(()=&gt; &#123;</span></span><br><span class="line"><span class="comment"> *   console.log(&#x27;xxx&#x27;);</span></span><br><span class="line"><span class="comment"> * &#125;, 200);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> timerMap = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mySetInterval</span>(<span class="params">callback, duration</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> timerId = id;</span><br><span class="line">id++;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">callback</span>();</span><br><span class="line">timerMap[timerId] = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line">&#125;, duration)</span><br><span class="line">&#125;</span><br><span class="line">timerMap[timerId] = <span class="built_in">setTimeout</span>(fn, duration);</span><br><span class="line"><span class="keyword">return</span> timerMap[timerId];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">timer</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * const timer = mySetInterval(()=&gt; &#123;</span></span><br><span class="line"><span class="comment"> *   console.log(&#x27;xxx&#x27;);</span></span><br><span class="line"><span class="comment"> * &#125;, 200);</span></span><br><span class="line"><span class="comment"> * setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="comment"> *   myClearInterval(timer);</span></span><br><span class="line"><span class="comment"> * &#125;, 1000);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myClearInterval</span>(<span class="params">timer</span>) &#123;</span><br><span class="line"><span class="built_in">clearTimeout</span>(timerMap[timer]);</span><br><span class="line"><span class="comment">// clearTimeout(timer);</span></span><br><span class="line"><span class="keyword">delete</span> timerMap[timer];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/6844903839934447629">用setTimeout和clearTimeout简单实现setInterval与clearInterval</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、另类排序&quot;&gt;&lt;a href=&quot;#一、另类排序&quot; class=&quot;headerlink&quot; title=&quot;一、另类排序&quot;&gt;&lt;/a&gt;一、另类排序&lt;/h2&gt;&lt;p&gt;题目：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js源码实现-reduce-isArray</title>
    <link href="https://tauleos.github.io/6aef7f739395.html"/>
    <id>https://tauleos.github.io/6aef7f739395.html</id>
    <published>2020-10-27T03:46:38.000Z</published>
    <updated>2024-11-06T08:27:08.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><blockquote><p><code>reduce()</code> 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终为一个值，是<em>ES5</em>中新增的又一个数组逐项处理方法</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><div class='tip'>arr.reduce(callback[, initialValue]) </div><h3 id="参数图解"><a href="#参数图解" class="headerlink" title="参数图解"></a>参数图解</h3><p><img src="images/reduce/reduce.jpg" alt="reduce"></p><h3 id="原理实现"><a href="#原理实现" class="headerlink" title="原理实现"></a>原理实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myReduce</span> = <span class="keyword">function</span>(<span class="params">callbackFn,initialValue</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">let</span> len = self.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> accumulator = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 参数不是函数报错</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> callbackFn !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callbackFn +<span class="string">&#x27;is not a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数组为空，并且有初始值，报错</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>&lt;<span class="number">2</span> &amp;&amp; len === <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Reduce of empty array with no initial value&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  initialValue = initialValue || <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 设置累加器为初始值，如果没有设置为数组的第一个元素</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">arguments</span>.<span class="property">length</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    accumulator = initialValue;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    accumulator = self[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(index&lt;len)&#123;</span><br><span class="line">    <span class="keyword">if</span>(self.<span class="title function_">hasOwnProperty</span>(index))&#123;</span><br><span class="line">      <span class="keyword">let</span> val = self[index];</span><br><span class="line">      accumulator = callbackFn.<span class="title function_">apply</span>(<span class="literal">null</span>,[accumulator,val,index,self]);</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> accumulator;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rReduce = [<span class="string">&#x27;1&#x27;</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, , <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> mReduce = [<span class="string">&#x27;1&#x27;</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, , <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">myReduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rReduce, mReduce);</span><br><span class="line"><span class="comment">// 31nullundefined34 31nullundefined34</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="isArray"><a href="#isArray" class="headerlink" title="isArray"></a>isArray</h2><blockquote><p><code>Array.isArray()</code> 用于确定传递的值是否是一个 <code>Array</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property">myIsArray</span> = <span class="keyword">function</span>(<span class="params">target</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(target) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">myIsArray</span>([])) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">myIsArray</span>(&#123;&#125;)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>完~</p><p>参考</p><ul><li><a href="https://mp.weixin.qq.com/s/Qqh1H-2MUyVGoWjgOstQrg">干货！阿里P6手写源码面试题集锦</a></li><li><a href="https://aotu.io/notes/2016/04/14/js-reduce/index.html">JavaScript中reduce()方法不完全指南</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Reduce&quot;&gt;&lt;a href=&quot;#Reduce&quot; class=&quot;headerlink&quot; title=&quot;Reduce&quot;&gt;&lt;/a&gt;Reduce&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;reduce()&lt;/code&gt; 方法接收一个函数作为累加器，数组中的每</summary>
      
    
    
    
    
    <category term="js" scheme="https://tauleos.github.io/tags/js/"/>
    
    <category term="源码" scheme="https://tauleos.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>自动化版本管理探索</title>
    <link href="https://tauleos.github.io/b7436f608b7a.html"/>
    <id>https://tauleos.github.io/b7436f608b7a.html</id>
    <published>2020-10-15T06:38:46.000Z</published>
    <updated>2024-11-06T08:27:08.638Z</updated>
    
    <content type="html"><![CDATA[<p>在我们日常Coding过程中，经常会有开发类库的需求</p><span id="more"></span><p>开发完成发布之后，后续版本管理，更新日志等问题也随之而来，如何解决这些问题呢？</p><h1 id="一、手打"><a href="#一、手打" class="headerlink" title="一、手打"></a>一、手打</h1><ul><li>手动更改版本号</li><li>手动变成更新日志</li><li>手动发布到npm私服</li><li>噢耶，完工</li></ul><div class="tip">你确定你是认真的么❓️❓️❓️手动黑人问号脸都2020年了还不能自动化吗？</div><h1 id="二、自动化"><a href="#二、自动化" class="headerlink" title="二、自动化"></a>二、自动化</h1><p>回到正题，如果有一种工具，我们只需要简单输入命令行，轻轻敲一下回车，就可以轻松帮我们完成手动的那些工作，。我们只需要噢耶，岂不快哉。</p><p>于是，在伟大的github上捕捉到了以下三种工具</p><ul><li>standard-version</li><li>semantic-release</li><li>lerna</li></ul><hr><blockquote><p>让我们来详细的分别了解一下这三位选手</p></blockquote><h2 id="1、Lerna"><a href="#1、Lerna" class="headerlink" title="1、Lerna"></a>1、Lerna</h2><p>不用说。先淘汰吧😂️。毕竟这家伙核心价值是多项目管理，跟我们的需求毫不沾边</p><h2 id="2、standard-version"><a href="#2、standard-version" class="headerlink" title="2、standard-version"></a>2、standard-version</h2><p>根据介绍，它的核心价值观在于语义化版本控制、打tag以及CHANGELOG生成。更为加分的是它还是代码提交规范组织的官方出品<br><img src="/images/version-management/standard-version.png" alt="sv"></p><blockquote><p>A utility for versioning using semver and CHANGELOG generation powered by Conventional Commits. </p></blockquote><p>听上去蛮符合我们的要求，使用方法也简单</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">standard-version</span><br></pre></td></tr></table></figure><p>基本上可以满足我们的日常需求。使用起来也满足我们的初始目标，一键Enter，搞定所有，我们只需要将更改推送到服务器，并且发布就好</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push --follow-tags origin master &amp;&amp; npm publish</span><br></pre></td></tr></table></figure><h2 id="3、semantic-release"><a href="#3、semantic-release" class="headerlink" title="3、semantic-release"></a>3、semantic-release</h2><p>打开文档介绍，原来这货的核心驱动力在于workflow。</p><blockquote><p>semantic-release automates the whole package release workflow including: determining the next version number, generating the release notes and publishing the package.</p></blockquote><p>相比楼上那位，该选手给我们提供了一整套完备的工作流，通过它我们可以:</p><ul><li>全自动release</li><li>强制语义化说明</li><li>插件化配置</li><li>与CI/CD默认集成<br>剩下的还有好多。。。大家可以去官网看。。。</li></ul><p>使用方法<br>A、使用的话会稍微复杂一点，类似babel，需要在项目中增加一个 <strong>.releaserc</strong> 文件进行插件配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;branches&quot;</span>: <span class="string">&quot;master&quot;</span>,</span><br><span class="line">  <span class="comment">// &quot;debug&quot;: true,</span></span><br><span class="line">  <span class="comment">// &quot;dryRun&quot;: true, // semantic-release默认在ci中工作，如果需要调试可以打开这个开关</span></span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;@semantic-release/commit-analyzer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@semantic-release/release-notes-generator&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@semantic-release/changelog&quot;</span>,</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@semantic-release/npm&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;npmPublish&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;tarballDir&quot;</span>: <span class="string">&quot;dist&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@semantic-release/git&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;assets&quot;</span>: [<span class="string">&quot;package.json&quot;</span>, <span class="string">&quot;CHANGELOG.md&quot;</span>],</span><br><span class="line">        <span class="string">&quot;message&quot;</span>: <span class="string">&quot;chore(蛋糕):$&#123;nextRelease.version&#125; [skip ci]\n\n$&#123;nextRelease.notes&#125;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@semantic-release/gitlab&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;gitlabUrl&quot;</span>: <span class="string">&quot;https://git.com/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;assets&quot;</span>: <span class="string">&quot;dist/*.tgz&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;preset&quot;</span>: <span class="string">&quot;angular&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B、同时需要在ci中增加配置，在项目中配置CI所需要的环境变量,包括<code>GL_TOKEN</code>、<code>NPM_USERNAME</code>、<code>NPM_EMAIL</code>、<code>NPM_PASSWORD</code>等</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="comment"># - test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">release</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">publish:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">node:10</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">release</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&#x27;//registry.npm.org/:username=$&#123;NPM_USERNAME&#125;&#x27;</span><span class="string">&gt;&gt;.npmrc</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&#x27;//registry.npm.org/:email=$&#123;NPM_EMAIL&#125;&#x27;</span><span class="string">&gt;&gt;.npmrc</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&#x27;//registry.npm.org/:_password=$&#123;NPM_PASSWORD&#125;&#x27;</span><span class="string">&gt;&gt;.npmrc</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npx</span> <span class="string">semantic-release</span></span><br></pre></td></tr></table></figure><p>C、最重要的一点，需要在gitlab中开启<code>PersonalAccessToken</code>（<del>前提是开启2FA配置，照着步骤走，挺麻烦的也能走通</del>后来发现不用开启2FA也能走通，那可太棒了），并设置在CI/CD的变量中<br><img src="/images/version-management/pas.png" alt="pat"></p><p>D、上述步骤做好，便可以把所有改动推送到远程仓库，坐等它带给你的惊喜</p><div class="tip">哈哈，其实除了跟楼上一样的效果之外，还额外生成了gitLab中的Release。当然如果不需要的话也可以干掉它，不过这么专业的操作，为啥不保留呢，对不对~😄️</div><h2 id="4、standard-version-VS-semantiv-release"><a href="#4、standard-version-VS-semantiv-release" class="headerlink" title="4、standard-version VS semantiv-release"></a>4、standard-version VS semantiv-release</h2><table><thead><tr><th align="center">功能点</th><th align="center">standard-version</th><th align="center">semantic-release</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">版本控制</td><td align="center">✅</td><td align="center">✅</td><td align="center">会根据提交的信息类型来自动更改对应的版本号,如下:<br> feat: 次版本(minor)+1 <br>  fix: 修订号(patch) +1 <br> BREAK CHANGE: 主板号(marjor) +1</td></tr><tr><td align="center">CHANGELOG</td><td align="center">✅</td><td align="center">✅</td><td align="center">均基于Angular Commit 规则</td></tr><tr><td align="center">gitTag标记</td><td align="center">✅</td><td align="center">✅</td><td align="center"></td></tr><tr><td align="center">npm自动发布</td><td align="center"></td><td align="center">✅</td><td align="center"></td></tr><tr><td align="center">CI集成</td><td align="center">⚠️️</td><td align="center">✅</td><td align="center">standard-version 可以手动实现</td></tr><tr><td align="center">pre-release实现</td><td align="center">✅</td><td align="center">✅</td><td align="center">standard-version：通过可选参数<br>semantic-release:通过分支设置</td></tr><tr><td align="center">gitlab release</td><td align="center"></td><td align="center">✅</td><td align="center"></td></tr></tbody></table><h1 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h1><p>standard-version与semantic-release 都是令人惊叹的工具，不管使用哪一个都能够最大限度的满足我们的需求。当然两个工具的侧重点是不一样的。所以我们可以根据自己的喜好来选择。<br>在我个人看来：</p><div class="tip">standard-version 偏向于小工具开发，自行决定类库的版本，并且可以在发布前进行修改semantic-release 偏向于workflow，多人协作下通过mr进行需求的迭代</div>当然，无论采取哪种姿势，我们的核心目标只有一个：<p><img src="/images/version-management/dkam.png" alt="killAllHumans"><br>完~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我们日常Coding过程中，经常会有开发类库的需求&lt;/p&gt;</summary>
    
    
    
    
    <category term="架构" scheme="https://tauleos.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>细说HTTP Cache</title>
    <link href="https://tauleos.github.io/fa64e05e0810.html"/>
    <id>https://tauleos.github.io/fa64e05e0810.html</id>
    <published>2019-05-07T02:27:48.000Z</published>
    <updated>2024-11-06T08:27:08.638Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/1557042361870.png" alt="headers"></p><span id="more"></span><p>在之前的文章<a href="https://tauleos.github.io/652b679860cc.html">浏览器缓存理论</a>中，我们详细解释了浏览器缓存的几种方式，其中的Disk Cache主要使用的便是HTTP协议中的缓存机制。浏览器会根据请求的结果和缓存标识，会判断是直接从缓存中读取数据还是向服务器发请求判断缓存的有效性，前者被称为<strong>强缓存</strong>，后者被称为<strong>协商缓存</strong>。</p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>即不会向服务器发请求获取资源，直接在缓存中读取数据。在控制台中 HTTP status 为200,Size 显示from memory cache 或者 from disk cache;由两个http header 字段来控制：<strong>Expires和Cache-Control</strong>。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><ul><li>用来指定资源到期的时间,是一个具体的时间点。</li><li>是HTTP/1的产物，如果修改了本地时间，会造成缓存失效。有一定的局限性。</li></ul><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>是HTTP/1.1的产物，可以组合多种指令</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>public</td><td>表示可以被客户端和代理服务器缓存</td></tr><tr><td>private</td><td>表示只可以被客户端缓存</td></tr><tr><td>max-age=30</td><td>资源30秒之后就过期，需要重新请求</td></tr><tr><td>s-max-age=30</td><td>覆盖max-age,作用相同，只在<strong>代理服务器</strong>中生效</td></tr><tr><td>no-store</td><td>不缓存任何响应</td></tr><tr><td>no-cache</td><td>资源会被缓存，但是立即失效，下次会发起请求验证资源是否过期</td></tr><tr><td>max-scale=30</td><td>30秒内，即使缓存过期，也使用该资源(无敌金身期)</td></tr><tr><td>min-fresh=30</td><td>希望在30秒内获取最新的响应</td></tr></tbody></table><div class="tip">强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新</div><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>在强缓存失效之后，浏览器会携带缓存标识向服务器发起请求，服务器会根据缓存标识来和浏览器协商资源的缓存情况，这一过程称之为协商缓存。协商成功，返回304和空的响应体，协商失败，返回200和新的资源。</p><h2 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h2><ul><li>浏览器在第一次访问资源的时候，服务器会在response header中加入last-Modified=timevalue(该资源的最后修改时间)，浏览器接收到响应，会将资源和header一同缓存起来。</li><li>浏览器再次请求该资源时，会将Last-Modified的值timevalue放在If-Modified-Since中，即If-Modified-Since=timevalue</li><li>服务器接收到请求，会将timevalue与该资源的最后修改时间进行对比，如果没有变化，返回304和空的响应体，如果timevalue小于最后修改时间，说明资源发生了变化，返回200和新的资源。</li></ul><p>但是Last-Modified存在一些弊端：</p><ul><li>如果本地打开缓存文件，不管有没有修改，都会造成Last-Modified 的值发生变化，服务端不能命中缓存导致发送同样的资源</li><li>因为Last-Modified的值是以秒为最小单位，如果在不可感知的时间内修改完成文件，服务端还是会认为资源会命中，不返回正确的资源。</li></ul><h2 id="Etag和If-None-Match"><a href="#Etag和If-None-Match" class="headerlink" title="Etag和If-None-Match"></a>Etag和If-None-Match</h2><p><strong>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成</strong>。</p><ul><li>同上面Last_Modified类似,第一次请求的时候，服务器会生成一个唯一标示作为Etag的值(hashvalue)返回给浏览器</li><li>浏览器再次请求资源的时候，会把hashvalue(Etag的值)作为请求头里的If-None-Match 的值。服务器只需要比对这两个值是否一致，就可以很好地判断资源有没有被修改过。</li></ul><h2 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h2><ul><li>在精度上，Etag优于Last-Modified</li><li>在性能上，Etag逊于Last-Modified</li><li>在优先级上，Etag高于Last-Modified</li></ul><h1 id="缓存优先级"><a href="#缓存优先级" class="headerlink" title="缓存优先级"></a>缓存优先级</h1><ul><li>强缓存优先于协商缓存</li><li>如果没有设置任何缓存策略，浏览器会采用启发式算法，通常会取响应头中的Date减去Last-Modified 值的 10% 作为缓存时间。</li></ul><p>参考文章</p><p><a href="https://juejin.im/post/5c22ee806fb9a049fb43b2c5">一文读懂前端缓存</a></p><p><a href="https://www.jianshu.com/p/54cc04190252">深入理解浏览器的缓存机制</a></p><p><a href="http://www.alloyteam.com/2016/03/discussion-on-web-caching/">浅谈Web缓存</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/1557042361870.png&quot; alt=&quot;headers&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="理论" scheme="https://tauleos.github.io/tags/%E7%90%86%E8%AE%BA/"/>
    
    <category term="http" scheme="https://tauleos.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>React组件的生命周期</title>
    <link href="https://tauleos.github.io/5720ed7e6faf.html"/>
    <id>https://tauleos.github.io/5720ed7e6faf.html</id>
    <published>2019-04-26T09:05:02.000Z</published>
    <updated>2024-11-06T08:27:08.634Z</updated>
    
    <content type="html"><![CDATA[<p>组件从被创建到被销毁的过程称为组件的生命周期。React为组件在不同的生命周期阶段提供了不同的生命周期方法，让开发者可以更好地控制组件的行为。<br> <strong>注意：只有class component 才具有生命周期方法，functional component 是没有生命周期方法的。因此不要在functional component中使用生命周期方法</strong></p><span id="more"></span><h1 id="生命周期如图所示"><a href="#生命周期如图所示" class="headerlink" title="生命周期如图所示"></a>生命周期如图所示</h1><p><img src="/images/1556269802577.webp" alt="生命周期图"></p><h1 id="生命周期的三个阶段"><a href="#生命周期的三个阶段" class="headerlink" title="生命周期的三个阶段"></a>生命周期的三个阶段</h1><h2 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h2><blockquote><p>这个阶段组件被创建，执行初始化,并被挂载到DOM中，完成组件的第一次渲染。该阶段的方法有:</p><p>1.<a href="#constructor">constructor</a><br>2.<a href="#componentWillMount">componentWillMount</a><br>3.<a href="#render">render</a><br>4.<a href="#componentDidMount">componentDidMount</a></p></blockquote><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>这是ES6的<strong>class</strong>的构造方法，通常用于<strong>初始化组件的state以及绑定事件处理方法等工作</strong></p><h3 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h3><p>这个方法在组件被挂载到DOM前调用，<strong>且只会被调用一次</strong>，这个方法在实际项目中<strong>很少</strong>会用到，因为可以在该方法中执行的工作都可以提前到<strong>constructor</strong>中。<strong>在这个方法中调用setState不会引起组件的重新渲染</strong></p><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>根据组件的pops和state返回一个React元素，该元素用于描述组件的UI。在该方法中不能执行任何有副作用的操作，所以不能在render中调用setState，会改变组件的状态。</p><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p>在组件被挂载到DOM后调用，<strong>且只会被调用一次</strong>。这个时候已经可以获取到DOM结构，<strong>因此依赖DOM节点的操作可以放到这个方法中。这个方法通常还用于向服务端请求数据</strong>。调用this.setState 会引起组件的重新渲染。</p><h2 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h2><p>组件被挂载到DOM后，组件的props或state改变会引起组件的更新。</p><ul><li>props引起的更新，本质上是由渲染该组件的父组件引起的(也就是当父组件的render方法被调用时，组件会发生更新过程)，无论props是否改变，父组件render方法每一次调用，都会导致组件更新。</li><li>state引起的组件更新，是通过this.setState修改组件的state触发的。<br>组件更新阶段依次调用的方法有：</li></ul><p>1.<a href="#componentWillReceiveProps(nextProps)">componentWillReceiveProps</a><br>2.<a href="#shouldComponentUpdate(nextProps,nextState)">shouldComponentUpdate</a><br>3.<a href="#componentWillUpdate">componentWillUpdate</a><br>4.<a href="#render">render</a><br>5.<a href="#componentDidUpdate(prevProps,prevState)">componentDidUpdate</a></p><h3 id="componentWillReceiveProps-nextProps"><a href="#componentWillReceiveProps-nextProps" class="headerlink" title="componentWillReceiveProps(nextProps)"></a>componentWillReceiveProps(nextProps)</h3><ul><li>该方法只在props引起的组件更新过程中，才会被调用。state引起的组件更新并不会触发。</li><li>nextProps是父组件传递给当前组件的新的props</li><li>nextProps的值可能与子组件当前props的值相同，因此往往需要比较他俩的值来决定是否执行props发生变化后的逻辑。</li><li> <strong>在该方法中调用setState，只有render以及之后的方法中。this.state指向的才是更新后的state。在之前的shouldComponentUpdate、componentWillUpdate中。this.state指向的还是更新前的state</strong></li></ul><h3 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps,nextState)"></a>shouldComponentUpdate(nextProps,nextState)</h3><ul><li>该方法决定组件是否继续执行更新过程。当该方法返回true(默认值)时继续执行，返回false时停止执行</li><li>一般通过比较nextProps、nextState与组件当前的props、state来决定返回值。</li><li>该方法可用来减少不必要的渲染，从而<strong>优化组件的性能</strong></li></ul><h3 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h3><p>该方法在组件render之前调用执行，可以作为组件更新前执行某些工作的地方。一般很少用到</p><blockquote><p>shouldComponentUpdate 与componentWillUpdate中不能调用this.setState,否则会引起循环调用问题，render永远无法被调用，组件也永远无法渲染</p></blockquote><h3 id="componentDidUpdate-prevProps-prevState"><a href="#componentDidUpdate-prevProps-prevState" class="headerlink" title="componentDidUpdate(prevProps,prevState)"></a>componentDidUpdate(prevProps,prevState)</h3><p>组件更新后被调用，可以作为操作更新后的DOM的地方。两个参数代表组件更新前的props和state</p><h2 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h2><p>组件的卸载阶段只有一个方法：</p><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><p>该方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚定时器，清除<a href="#didMount">componentDidMount</a>中手动创建的DOM元素等等。防止内存泄露</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;组件从被创建到被销毁的过程称为组件的生命周期。React为组件在不同的生命周期阶段提供了不同的生命周期方法，让开发者可以更好地控制组件的行为。&lt;br&gt; &lt;strong&gt;注意：只有class component 才具有生命周期方法，functional component 是没有生命周期方法的。因此不要在functional component中使用生命周期方法&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="js" scheme="https://tauleos.github.io/tags/js/"/>
    
    <category term="react" scheme="https://tauleos.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存理论</title>
    <link href="https://tauleos.github.io/652b679860cc.html"/>
    <id>https://tauleos.github.io/652b679860cc.html</id>
    <published>2019-04-12T07:25:49.000Z</published>
    <updated>2024-11-06T08:27:08.637Z</updated>
    
    <content type="html"><![CDATA[<p>缓存可以说是性能优化中简单高效的一种优化方式，可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</p><span id="more"></span><h1 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h1><ul><li><a href="#Service-Worker">Service Worker</a></li><li><a href="#Memory-Cache">Memory Cache</a></li><li><a href="#DisK-Cache">DisK Cache</a></li><li><a href="#Push-Cache">Push Cache</a></li></ul><h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能，必须基于HTTPS协议。<strong>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</strong><br>Service Worker 实现缓存功能一般分为三个步骤：</p><ul><li>注册service Worker</li><li>监听install时间</li><li>缓存需要的文件</li></ul><p>缓存之后，Service Worker 可以拦截下次的请求来查询是否存在缓存。如果没有命中缓存，需要使用fetch函数去请求数据(根据缓存优先级来获取数据；但是还是现实在Service Worker中获取的内容)。</p><h2 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h2><p>Memory Cache 是内存中的缓存，主要包括当前页面中已经抓取的资源(已经下载的样式、脚本、图片等)。在内存中读取缓存速度快，读取高效，但是持续性很短，会跟随进程的释放而释放。<br>以下几种情况下资源会被缓存在Memory Cache中：</p><ul><li>被预加载器(Preloader)获取的。</li><li>预加载指令(<link rel=preload>)</li><li>之前的DOM阶段或者CSS规则引起的请求。</li></ul><p>但是Memory Cache不会轻易的命中一个请求，除了要有匹配的URL，还要有相同的资源类型、CORS模式以及一些其他特性。</p><blockquote><p>Memory Cache匹配规则在标准中没有详尽的描述，所以不同的浏览器内核在实现上会有所不同。</p></blockquote><blockquote><p>Memory Cache是不关心HTTP语义的，比如Cache-Control: max-age=0的资源，仍然可以在同一个导航中被重用。但是在特定的情况下，Memory Cache会遵守Cache-Control: no-store指令，不缓存相应的资源。</p></blockquote><h2 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h2><p>Disk Cache 也就是我们经常说的HTTP Cache,顾名思义，它是存储在硬盘中的缓存，具有较强的时效性和大的容量性。<br>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？关于这点，网上说法不一，不过以下观点比较靠得住：</p><ul><li>对于大文件来说，大概率是不存储在内存中的，反之优先</li><li>当前系统内存使用率高的话，文件优先存储进硬盘</li></ul><h2 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h2><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><ul><li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</li><li>可以推送 no-cache 和 no-store 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>你可以给其他域名推送资源</li></ul><blockquote><p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p></blockquote><h1 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h1><p><img src="/images/1557055357514.png" alt="img"><br>由上图可知：</p><ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中<br>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取</li></ul><p>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">mdn</a><br><a href="https://www.jianshu.com/p/54cc04190252">深入理解浏览器的缓存机制</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;缓存可以说是性能优化中简单高效的一种优化方式，可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。&lt;/p&gt;</summary>
    
    
    
    
    <category term="理论" scheme="https://tauleos.github.io/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>太极图案</title>
    <link href="https://tauleos.github.io/3710a8c65723.html"/>
    <id>https://tauleos.github.io/3710a8c65723.html</id>
    <published>2019-04-12T07:25:18.000Z</published>
    <updated>2024-11-06T08:27:08.637Z</updated>
    
    <content type="html"><![CDATA[<div class="yinyang"></div><style>  .yinyang{    display:flex;    align-items:center;    --color1: white;    --color2: black;    border-radius: 50%;    box-shadow:0 0 1em rgba(0,0,0,0.3);    width:20em;    height:20em;    /* background:lightgray; */    background-image: linear-gradient(var(--color1) 50% ,var(--color2) 50%);    animation:rotating linear 3s infinite;  }  .yinyang::before{    content:'';    box-sizing:border-box;    width:50%;    height:50%;    border-radius:50%;    border: 3em solid var(--color1);    background-color: var(--color2);    /* mix-blend-mode:screen; */  }  .yinyang::after{    content:'';    box-sizing:border-box;    width:50%;    height:50%;    border-radius:50%;    border: 3em solid var(--color2);    background-color: var(--color1);    /* mix-blend-mode:screen; */  }  @keyframes rotating {    to{      transform: rotate(360deg);    }  }</style>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;yinyang&quot;&gt;&lt;/div&gt;
&lt;style&gt;
  .yinyang{
    display:flex;
    align-items:center;
    --color1: white;
    --color2: black;
    bord</summary>
      
    
    
    
    
    <category term="css" scheme="https://tauleos.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>js源码实现-call,apply,bind</title>
    <link href="https://tauleos.github.io/633b725634cd.html"/>
    <id>https://tauleos.github.io/633b725634cd.html</id>
    <published>2019-04-12T07:13:59.000Z</published>
    <updated>2024-11-06T08:27:08.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><blockquote><p><code>call、apply、bind</code> 本质都是改变 <code>this</code> 的指向，不同点 <code>call、apply</code> 是直接调用函数，<code>bind</code> 是返回一个新的函数。<code>call</code> 跟 <code>apply</code> 就只有参数上不同。</p><blockquote><p>区别就是<code>call()</code>方法接受的是参数列表，而<code>apply()</code>方法接受的是一个参数数组。</p></blockquote></blockquote><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>箭头函数的 <code>this</code> 永远指向它所在的作用域</li><li>函数作为构造函数用 <code>new</code> 关键字调用时，不应该改变其 <code>this</code> 指向，因为 <code>new绑定</code> 的优先级高于 <code>显示绑定</code> 和 <code>硬绑定</code></li></ul><p>代码实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&#x27;must be a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拿到参数传给调用者</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="variable language_">this</span>,</span><br><span class="line">  <span class="comment">// 构建一个干净的函数，用于保存原函数的原型</span></span><br><span class="line">  nop = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定的函数</span></span><br><span class="line">  bound = <span class="keyword">function</span> (<span class="params">...selfArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="comment">// this instanceof nop, 判断是否使用 new 来调用 bound</span></span><br><span class="line">      <span class="comment">// 如果是 new 来调用的话，this的指向就是其实例，</span></span><br><span class="line">      <span class="comment">// 如果不是 new 调用的话，就改变 this 指向到指定的对象 o</span></span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> nop ? <span class="variable language_">this</span> : thisArg,</span><br><span class="line">      args.<span class="title function_">concat</span>(selfArgs)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 箭头函数没有 prototype，箭头函数this永远指向它所在的作用域</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">    nop.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修改绑定函数的原型指向</span></span><br><span class="line">  bound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">nop</span>();</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bound = bar.<span class="title function_">mybind</span>(foo, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">bound</span>(); <span class="comment">// bar, [22, 33, 44]</span></span><br><span class="line"><span class="title function_">bound</span>(); <span class="comment">// foo, [22, 33, 44]</span></span><br></pre></td></tr></table></figure><h2 id="Call-amp-Apply"><a href="#Call-amp-Apply" class="headerlink" title="Call &amp; Apply"></a>Call &amp; Apply</h2><h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><blockquote><p><code>bind</code> 是封装了 <code>call</code> 的方法改变了 <code>this</code> 的指向并返回一个新的函数，那么 <code>call</code> 是如何做到改变 <code>this</code> 的指向呢？原理很简单，在方法调用模式下，<code>this</code> 总是指向调用它所在方法的对象，<code>this</code> 的指向与所在方法的调用位置有关，而与方法的声明位置无关（箭头函数特殊）。先写一个小 demo 来理解一下下。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">foo.<span class="property">fn</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 这里的 this 指向了 foo</span></span><br><span class="line">  <span class="comment">// 因为 foo 调用了 fn，</span></span><br><span class="line">  <span class="comment">// fn 的 this 就指向了调用它所在方法的对象 foo 上</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// foo</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以利用<code>this</code>的这个特性来实现call</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">thisArg = thisArg || <span class="variable language_">window</span>;</span><br><span class="line"><span class="comment">// 将调用call函数的对象添加到thisArg的属性中</span></span><br><span class="line">thisArg.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"><span class="keyword">const</span> result = thisArg.<span class="title function_">fn</span>(...args);</span><br><span class="line"><span class="keyword">delete</span> thisArg.<span class="property">fn</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">thisArg = thisArg || <span class="variable language_">window</span>;</span><br><span class="line">thisArg.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line"><span class="keyword">const</span> args = <span class="variable language_">arguments</span>[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">const</span> result = thisArg.<span class="title function_">fn</span>(...args);</span><br><span class="line"><span class="keyword">delete</span> thisArg.<span class="property">fn</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar.<span class="title function_">myCall</span>(foo, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// foo [1, 2, 3]</span></span><br><span class="line">bar.<span class="title function_">myApply</span>(foo, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// foo [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>完~<br><br><br>参考</p><ul><li><a href="https://mp.weixin.qq.com/s/Qqh1H-2MUyVGoWjgOstQrg">干货！阿里P6手写源码面试题集锦</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;call、apply、bind&lt;/code&gt; 本质都是改变 &lt;code&gt;this&lt;/code&gt; 的指向</summary>
      
    
    
    
    
    <category term="js" scheme="https://tauleos.github.io/tags/js/"/>
    
    <category term="源码" scheme="https://tauleos.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>js基础夯实-彻底搞懂this的指向问题</title>
    <link href="https://tauleos.github.io/a74d1e8039ab.html"/>
    <id>https://tauleos.github.io/a74d1e8039ab.html</id>
    <published>2019-04-12T01:28:57.000Z</published>
    <updated>2024-11-06T08:27:08.635Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>this 关键字是 JavaScript 中最复杂的机制之一，是一个特别的关键字，被自动定义在所有函数的作用域中.</p></blockquote><span id="more"></span><h1 id="为什么要搞懂this"><a href="#为什么要搞懂this" class="headerlink" title="为什么要搞懂this"></a>为什么要搞懂this</h1><ul><li>面向oop编程需要知道什么是this</li><li>在各种function调用过程中可以清晰的弄懂为什么。</li><li>可以更好的理解大师们的代码</li><li>防止面试被咔嚓。。。（血的教训）</li></ul><h1 id="this是什么？"><a href="#this是什么？" class="headerlink" title="this是什么？"></a>this是什么？</h1><p>顾名思义，this就是一个指针，但是他并不是指向自身！<strong>而是指向调用函数的对象</strong>。(这句话很重要。也是本篇文章贯穿始终的主旨。)</p><h1 id="this的指向判定标准"><a href="#this的指向判定标准" class="headerlink" title="this的指向判定标准"></a>this的指向判定标准</h1><h4 id="前人的判定"><a href="#前人的判定" class="headerlink" title="前人的判定"></a>前人的判定</h4><ol><li>函数是否是<code>new</code>调用，如果是，则指向<code>new</code>创建的实例。</li><li>函数是否是bind方法返回的？如果是，则this指向指定对象。</li><li>函数是否是通过<code>apply/call</code>调用的？如果是，则this指向指定对象。</li><li>是否作为对象的方法调用？ 如果是，则this指向该对象。</li><li>this指向全局。</li></ol><h4 id="为什么这样判定？"><a href="#为什么这样判定？" class="headerlink" title="为什么这样判定？"></a>为什么这样判定？</h4><p>为什么通过这五种方式来判定呢？我们首先要知道this的绑定规则有哪些？</p><ul><li>默认绑定</li><li>隐式绑定</li><li>显示绑定</li><li>new 绑定</li></ul><p>下面我们来分别挨个说明每个规则，来验证我们上述的判定标准。</p><h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>在不能应用其他绑定规则时使用的默认规则，通常是独立函数调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>,<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;mySelf&#x27;</span>;</span><br><span class="line"><span class="title function_">getName</span>()</span><br></pre></td></tr></table></figure><p>在调用<code>getName</code>的时候,应用了默认绑定，在非严格模式下<code>this</code>指向全局对象,严格模式下<code>this</code>是<code>undefined</code>,</p><ul><li>在浏览器模式下<code>this</code>指向了全局对象<code>window</code>,所以运行结果是<code>HellomySelf</code></li><li>在node环境下<code>this</code>指向的全局对象是<code>node-runtime</code></li></ul><blockquote><p>在该文章中我们主要讨论浏览器中的表现。</p></blockquote><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>函数的调用存在上下文关系,典型案例如abc.foo():</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tag</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tag = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">obj.<span class="title function_">func</span>();</span><br></pre></td></tr></table></figure><p>执行结果是<code>a</code>；那如果我把sayHi的定义提升到外边，如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tag</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: h</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tag = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line">obj.<span class="title function_">func</span>();</span><br></pre></td></tr></table></figure><p>执行结果跟上面是一样的。这是因为在函数<code>sayHi</code>调用的时候,此时的上下文对象属于<code>person</code>,<strong>隐式绑定会将函数中的<code>this</code>绑定到<code>person</code>这个上下文对象上</strong></p><blockquote><p>需要注意的是：在嵌套对象的调用时，只有离<code>this</code>最近的那一层会影响到调用位置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tag</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: h</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">tag</span>:<span class="string">&#x27;obj2&#x27;</span>,</span><br><span class="line">  <span class="attr">obj</span>:obj1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tag = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line">obj2.<span class="property">obj</span>.<span class="title function_">func</span>();</span><br></pre></td></tr></table></figure><p>结果是<code>obj1</code>,这是因为只有执行到<code>obj1.func</code>的时候，才能确定函数<code>h</code>中<code>this</code>指向的上下文对象为<code>obj1</code>.</p><div class="tip">    隐式绑定有一个很大的坑，就是会丢失绑定。也就是说，我们以为的this指向，其实并不是this真正的指向（我们以为他是雷锋，但是他却是雷峰塔）</div><p>隐式绑定的丢失主要体现在两个方面:</p><ol><li>函数重新赋值,如下面代码所示:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tag</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">tag</span>:<span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">  <span class="attr">func</span>:h</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tag = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> callh = obj1.<span class="property">func</span>;</span><br><span class="line"><span class="title function_">callh</span>(); <span class="comment">//window</span></span><br></pre></td></tr></table></figure></li></ol><p> <strong>这是因为<code>callh</code>直接指向了函数<code>h</code>的引用，在执行<code>callh</code>的时候上下文对象为<code>document.window</code></strong></p><ol start="2"><li>在回掉函数和事件回调中也会丢失绑定,如下代码所示<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tag</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">tag</span>:<span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">  <span class="attr">func</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tag</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">tag</span>:<span class="string">&#x27;obj2&#x27;</span>,</span><br><span class="line">  <span class="attr">func</span>:h</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tag = <span class="string">&#x27;window&#x27;</span></span><br><span class="line">obj1.<span class="title function_">func</span>(); <span class="comment">// window</span></span><br><span class="line"><span class="built_in">setTimeout</span>(obj2.<span class="property">func</span>,<span class="number">200</span>); <span class="comment">// window</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">  obj2.<span class="title function_">func</span>()</span><br><span class="line">&#125;,<span class="number">200</span>)           <span class="comment">//obj2</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>第一个输出是因为命中了默认绑定,<code>this</code>指向了<code>document.window</code></li><li>第二个输出是因为<code>obj2.func</code>赋值给了<code>setTimeout</code>的回调入参之后又执行这个入参，所以隐式绑定丢失，<code>this</code>指向了<code>document.window</code></li><li>第三条输出是因为命中了隐式绑定，<code>this</code>指向了<code>obj2</code></li></ul><h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>通过 <code>call,apply,bind</code> 的方式，显式的指定<code>this</code>所指向的对象。<code>call,apply,bind</code>的第一个参数，就是对应函数的<code>this</code>所指向的对象。<code>call</code>和<code>apply</code>的作用一样，只是传参方式不同。<code>call</code>和<code>apply</code>都会执行对应的函数，而<code>bind</code>方法不会。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">h</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">tag</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;obj1&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: h</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tag = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> h2 = <span class="keyword">function</span>(<span class="params">func</span>)&#123;</span><br><span class="line">  <span class="title function_">func</span>()</span><br><span class="line">&#125;</span><br><span class="line">h2.<span class="title function_">call</span>(obj1,obj1.<span class="property">func</span>)   <span class="comment">//window</span></span><br></pre></td></tr></table></figure><p><strong>因为<code>obj1.func</code>作为入参传入的时候,已经丢失了隐式绑定的<code>this</code></strong></p><h2 id="new关键字绑定"><a href="#new关键字绑定" class="headerlink" title="new关键字绑定"></a><code>new</code>关键字绑定</h2><p>使用<code>new</code>来调用函数，会自动执行下面的操作：</p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋值给新对象，即<code>this</code>指向这个新对象</li><li>执行构造函数中的代码</li><li>返回新对象</li></ol><h1 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h1><blockquote><p>new 绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p></blockquote><h1 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h1><p>如果我们将<code>null</code>或者是<code>undefined</code>作为<code>this</code>的绑定对象传入<code>call、apply、bind</code>, 这些值在调用时会被忽略，实际应用的是默认绑定规则。</p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数是 ES6 中新增的，它和普通函数有一些区别，箭头函数没有自己的 this，它的 this 继承于外层代码库中的 this。箭头函数在使用时，需要注意以下几点:</p><ul><li>函数体内的 this 对象，继承的是外层代码块的 this。</li><li>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</li><li>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li><li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</li><li>箭头函数没有自己的 this，所以不能用 call()、apply()、bind() 这些方法去改变 this 的指向.</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1 . 函数是否在 new 中调用 (new 绑定)，如果是，那么 this 绑定的是新创建的对象。<br>2 . 函数是否通过 call,apply 调用，或者使用了 bind(即硬绑定)，如果是，那么 this 绑定的就是指定的对象。<br>3 . 函数是否在某个上下文对象中调用 (隐式绑定)，如果是的话，this 绑定的是那个上下文对象。一般是 obj.foo()。<br>4 . 如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到 undefined，否则绑定到全局对象。<br>5 . 如果把 Null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。<br>6 . 如果是箭头函数，箭头函数的 this 继承的是外层代码块的 this。</p><p>参考</p><ul><li><a href="https://juejin.im/post/5c96d0c751882511c832ff7b">嗨，你真的懂this吗？</a></li><li><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html">Javascript 的 this 用法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;this 关键字是 JavaScript 中最复杂的机制之一，是一个特别的关键字，被自动定义在所有函数的作用域中.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="js" scheme="https://tauleos.github.io/tags/js/"/>
    
    <category term="理论" scheme="https://tauleos.github.io/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>mac-v10.9.5安装nginx</title>
    <link href="https://tauleos.github.io/abff08f12a22.html"/>
    <id>https://tauleos.github.io/abff08f12a22.html</id>
    <published>2019-03-25T11:04:45.000Z</published>
    <updated>2024-11-06T08:27:08.636Z</updated>
    
    
    
    
    
    <category term="mac" scheme="https://tauleos.github.io/tags/mac/"/>
    
    <category term="nginx" scheme="https://tauleos.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>安装redis</title>
    <link href="https://tauleos.github.io/5d3c72d7cf56.html"/>
    <id>https://tauleos.github.io/5d3c72d7cf56.html</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2024-11-06T08:27:08.636Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://redis.googlecode.com/files/redis-2.6.14.tar.gz</span><br><span class="line">tar -zxvf redis-2.6.14.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-2.6.14</span><br><span class="line">make</span><br><span class="line">make PREFIX=/usr/local/redis install</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="设置redis自启动"><a href="#设置redis自启动" class="headerlink" title="设置redis自启动"></a>设置redis自启动</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /usr/local/redis/&#123;etc,var&#125;</span><br><span class="line"><span class="built_in">cp</span> redis.conf /usr/local/redis/etc/</span><br></pre></td></tr></table></figure><h3 id="改配置"><a href="#改配置" class="headerlink" title="改配置"></a>改配置</h3><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">nano /etc/rc.local</span><br></pre></td></tr></table></figure><blockquote><p>在最后一行加入</p></blockquote><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">./usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</span><br><span class="line">nano /usr/local/redis/etc/redis.conf #修改redis-conf配置文件</span><br><span class="line">port 10087 #设置端口为10087</span><br><span class="line">requirepass ehncf2000  #设置访问密码</span><br><span class="line">daemonize yes #修改后台运行</span><br><span class="line">timeout 300   #请求超时时间</span><br><span class="line">loglevel debug #log信息级别</span><br><span class="line">dbfilename dump.rdb #数据文件</span><br><span class="line">dir /usr/local/redis/etc/ #数据文件目录</span><br></pre></td></tr></table></figure><h3 id="加环境变量"><a href="#加环境变量" class="headerlink" title="加环境变量"></a>加环境变量</h3><figure class="highlight console"><table><tr><td class="code"><pre><span class="line">nano /etc/environment</span><br><span class="line">/usr/local/redis/bin/redis-server</span><br><span class="line">/usr/local/redis/bin/redis-benchmark</span><br><span class="line">/usr/local/redis/bin/redis-cli</span><br></pre></td></tr></table></figure><h3 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;安装redis&quot;&gt;&lt;a href=&quot;#安装redis&quot; class=&quot;headerlink&quot; title=&quot;安装redis&quot;&gt;&lt;/a&gt;安装redis&lt;/h3&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget http://redis.googlecode.com/files/redis-2.6.14.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tar -zxvf redis-2.6.14.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; redis-2.6.14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make PREFIX=/usr/local/redis install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://tauleos.github.io/tags/linux/"/>
    
    <category term="redis" scheme="https://tauleos.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>kafka安装教程</title>
    <link href="https://tauleos.github.io/9151c631d8a6.html"/>
    <id>https://tauleos.github.io/9151c631d8a6.html</id>
    <published>2019-01-25T11:09:48.000Z</published>
    <updated>2024-11-06T08:27:08.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。<br><br><br>其主要应用场景是：日志收集系统和消息系统。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1、安装JDK-1-8-0"><a href="#1、安装JDK-1-8-0" class="headerlink" title="1、安装JDK 1.8.0"></a>1、安装JDK 1.8.0</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -jvh jdk-8u101-linux-x64.rpm</span><br><span class="line"><span class="comment">#验证是否安装成功</span></span><br><span class="line">java -version</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># java version &quot;1.8.0_101&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2、安装zookeeper"><a href="#2、安装zookeeper" class="headerlink" title="2、安装zookeeper"></a>2、安装zookeeper</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.8.tar.gz</span><br><span class="line"><span class="built_in">cd</span> zookeeper-3.4.8/conf</span><br><span class="line"><span class="built_in">mv</span> zoo_sample.cfg zoo.cfg</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">./bin/zkServer.sh start</span><br><span class="line"><span class="comment"># 开启后可以用下面命令检测是否运行成功</span></span><br><span class="line">ps aux |grep zookeeper</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3、安装kafka"><a href="#3、安装kafka" class="headerlink" title="3、安装kafka"></a>3、安装kafka</h3><h4 id="1、运行kafka"><a href="#1、运行kafka" class="headerlink" title="1、运行kafka"></a>1、运行kafka</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -zxvf kafka.tgz</span><br><span class="line"><span class="built_in">cd</span> /opt/kafka/bin</span><br><span class="line"><span class="built_in">nohup</span> ./kafka-server-start.sh /opt/kafka/config/server.properties &amp;</span><br></pre></td></tr></table></figure><h4 id="2、创建topic"><a href="#2、创建topic" class="headerlink" title="2、创建topic"></a>2、创建topic</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic data-test</span><br><span class="line"><span class="comment"># 创建成功控制台会显示：</span></span><br><span class="line"><span class="comment"># Created topic &quot;data-test&quot;.</span></span><br><span class="line"><span class="built_in">cd</span> bin/</span><br><span class="line"><span class="comment"># 查看topic列表</span></span><br><span class="line">./kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><h3 id="4、测试"><a href="#4、测试" class="headerlink" title="4、测试"></a>4、测试</h3><h4 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./kafka-console-producer.sh --broker-list localhost:9092 --topic <span class="built_in">test</span> Kafka <span class="built_in">test</span>!    </span><br><span class="line"><span class="comment"># 这里的“Kafka test!”为手动输入的，输入后“ctrl +c”退出；</span></span><br></pre></td></tr></table></figure><h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./kafka-console-consumer.sh --zookeeper localhost:2181 --topic <span class="built_in">test</span> --from-beginning I<span class="string">&#x27;m laoyang  </span></span><br><span class="line"><span class="string"># 之前测试输入的内容 kafka test!</span></span><br></pre></td></tr></table></figure><br><p>完~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做</summary>
      
    
    
    
    
    <category term="linux" scheme="https://tauleos.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>每日一条linux命令之ln</title>
    <link href="https://tauleos.github.io/c60b11b049f3.html"/>
    <id>https://tauleos.github.io/c60b11b049f3.html</id>
    <published>2018-08-04T08:43:17.000Z</published>
    <updated>2024-11-06T08:27:08.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><span id="more"></span><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote><p>ln [参数][源文件或目录][目标文件或目录]</p></blockquote><h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p><h4 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h4><ul><li>软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</li><li>软链接可以 跨文件系统 ，硬链接不可以</li><li>软链接可以对一个不存在的文件名进行链接</li><li>软链接可以对目录进行链接</li></ul><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><ul><li>硬链接，以文件副本的形式存在。但不占用实际空间</li><li>不允许给目录创建硬链接</li><li>硬链接只有在同一个文件系统中才能创建</li></ul><p><strong>这里有两点要注意：</strong></p><ul><li>ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化</li><li>ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。</li></ul><p>ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。</p><h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><p>必要参数:</p><p>-b 删除，覆盖以前建立的链接</p><p>-d 允许超级用户制作目录的硬链接</p><p>-f 强制执行</p><p>-i 交互模式，文件存在则提示用户是否覆盖</p><p>-n 把符号链接视为一般目录</p><p>-s 软链接(符号链接)</p><p>-v 显示详细的处理过程</p><p>选择参数:</p><p>-S “-S&lt;字尾备份字符串&gt; ”或 “–suffix=&lt;字尾备份字符串&gt;”</p><p>-V “-V&lt;备份方式&gt;”或“–version-control=&lt;备份方式&gt;”</p><p>–help 显示帮助信息</p><p>–version 显示版本信息</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://tauleos.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>php mysql批量插入</title>
    <link href="https://tauleos.github.io/6e9c090d6e03.html"/>
    <id>https://tauleos.github.io/6e9c090d6e03.html</id>
    <published>2017-10-01T14:37:41.000Z</published>
    <updated>2024-11-06T08:27:08.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Insert-Into："><a href="#一、Insert-Into：" class="headerlink" title="一、Insert Into："></a>一、Insert Into：</h2><blockquote><p>使用<code>insert into</code> 插入，代码如下：</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$params</span> = <span class="keyword">array</span>(‘value’=&gt;’<span class="number">50</span>′);</span><br><span class="line"><span class="title function_ invoke__">set_time_limit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">date</span>(“<span class="attr">H</span>:<span class="attr">i</span>:s”);</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="number">2000000</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line">  <span class="variable">$connect_mysql</span>-&gt;<span class="title function_ invoke__">insert</span>(<span class="variable">$params</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">date</span>(“<span class="attr">H</span>:<span class="attr">i</span>:s”); </span><br></pre></td></tr></table></figure><div class="tip">最后显示为：**23:25:05 01:32:05**, 。。。。。 也就是花了2个小时多! 😢</div><h2 id="二、事务"><a href="#二、事务" class="headerlink" title="二、事务"></a>二、事务</h2><blockquote><p>使用事务提交，批量插入数据库(每隔10W条提交下),代码如下：</p></blockquote><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">date</span>(“<span class="attr">H</span>:<span class="attr">i</span>:s”); </span><br><span class="line"><span class="variable">$connect_mysql</span>-&gt;<span class="title function_ invoke__">query</span>(‘BEGIN’);</span><br><span class="line"><span class="variable">$params</span> = <span class="keyword">array</span>(‘value’=&gt;’<span class="number">50</span>′);</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="number">2000000</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line">  <span class="variable">$connect_mysql</span>-&gt;<span class="title function_ invoke__">insert</span>(<span class="variable">$params</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="variable">$i</span>%<span class="number">100000</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="variable">$connect_mysql</span>-&gt;<span class="title function_ invoke__">query</span>(‘COMMIT’);<span class="variable">$connect_mysql</span>-&gt;<span class="title function_ invoke__">query</span>(‘BEGIN’);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$connect_mysql</span>-&gt;<span class="title function_ invoke__">query</span>(‘COMMIT’);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">date</span>(“<span class="attr">H</span>:<span class="attr">i</span>:s”); </span><br></pre></td></tr></table></figure><div class="tip">最后显示消耗的时间为：**22:56:13 23:04:00**，一共8分13秒.好像快了不少。。</div><h2 id="三、优化SQL语句"><a href="#三、优化SQL语句" class="headerlink" title="三、优化SQL语句"></a>三、优化SQL语句</h2><blockquote><p>使用优化SQL语句：将SQL语句进行拼接，使用 <code>insert into table () values  (),(),(),()</code>然后再一次性插入，</p><blockquote><p>如果字符串太长，则需要配置下MYSQL，在mysql 命令行中运行 ：</p></blockquote></blockquote><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> global max_allowed_packet =  2*1024*1024*10;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span>= “insert into <span class="title function_ invoke__">twenty_million</span> (value) values”; <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="number">2000000</span>;<span class="variable">$i</span>++)&#123; </span><br><span class="line">  <span class="variable">$sql</span>.=”(’<span class="number">50</span>′),”; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="variable">$sql</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$sql</span>,<span class="number">0</span>,<span class="title function_ invoke__">strlen</span>(<span class="variable">$sql</span>)-<span class="number">1</span>); <span class="variable">$connect_mysql</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="variable">$sql</span>); </span><br></pre></td></tr></table></figure><div class="tip">消耗时间为：11:24:06 11:25:06;插入200W条测试数据仅仅用了1分钟!</div><h2 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h2><p>在插入大批量数据时，第一种方法无疑是最差劲的，而第二种方法在实际应用中就比较广泛，第三种方法在插入测试数据或者其他低要求时比较合适，速度确实快。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Insert-Into：&quot;&gt;&lt;a href=&quot;#一、Insert-Into：&quot; class=&quot;headerlink&quot; title=&quot;一、Insert Into：&quot;&gt;&lt;/a&gt;一、Insert Into：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用&lt;code&gt;i</summary>
      
    
    
    
    
    <category term="php" scheme="https://tauleos.github.io/tags/php/"/>
    
    <category term="mysql" scheme="https://tauleos.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
